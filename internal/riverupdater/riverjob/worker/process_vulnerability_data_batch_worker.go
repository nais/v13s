package worker

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/nais/v13s/internal/collections"
	"github.com/nais/v13s/internal/database/sql"
	"github.com/nais/v13s/internal/riverupdater/riverjob"
	"github.com/nais/v13s/internal/riverupdater/riverjob/domain"
	"github.com/nais/v13s/internal/riverupdater/riverjob/job"
	"github.com/nais/v13s/internal/sources"
	"github.com/riverqueue/river"
	"github.com/sirupsen/logrus"
)

type ProcessVulnerabilityDataBatchWorker struct {
	Querier   sql.Querier
	JobClient riverjob.Client
	Log       logrus.FieldLogger
	river.WorkerDefaults[job.ProcessVulnerabilityDataBatchJob]
}

func (p *ProcessVulnerabilityDataBatchWorker) Work(ctx context.Context, j *river.Job[job.ProcessVulnerabilityDataBatchJob]) error {
	ctx = riverjob.NewRecorder(ctx)
	rec := riverjob.FromContext(ctx)
	defer rec.Flush(ctx)

	rec.Add("start", "ok", fmt.Sprintf("batch_count=%d", len(j.Args.Batches)))

	var errs []error

	var cveRows []sql.BatchUpsertCveParams
	var vulnRows []sql.BatchUpsertVulnerabilitiesParams
	var imgStateRows []sql.BatchUpdateImageStateParams
	var summaryImages []domain.Image

	for _, b := range j.Args.Batches {
		cveRows = append(cveRows, toCveSqlParams(b)...)
		vulnRows = append(vulnRows, toVulnerabilitySqlParams(ctx, p.Querier, b)...)
		imgStateRows = append(imgStateRows, sql.BatchUpdateImageStateParams{
			State: sql.ImageStateUpdated,
			Name:  b.ImageName,
			Tag:   b.ImageTag,
		})
		summaryImages = append(summaryImages, domain.Image{
			Name: b.ImageName,
			Tag:  b.ImageTag,
		})
	}

	rec.Add("collect_rows", "ok",
		fmt.Sprintf("cves=%d vulns=%d imgs=%d", len(cveRows), len(vulnRows), len(imgStateRows)),
	)

	// Batch CVE upsert
	rec.Add("upsert_cves", "start", fmt.Sprintf("count=%d", len(cveRows)))
	collections.SortByFields(cveRows, func(x sql.BatchUpsertCveParams) string { return x.CveID })
	cveErrCount := 0
	p.Querier.BatchUpsertCve(ctx, cveRows).Exec(func(_ int, err error) {
		if err != nil {
			cveErrCount++
			errs = append(errs, err)
		}
	})
	if cveErrCount > 0 {
		rec.Add("upsert_cves", "error", fmt.Sprintf("errors=%d", cveErrCount))
	} else {
		rec.Add("upsert_cves", "ok", "")
	}

	// Batch vuln upsert
	rec.Add("upsert_vulns", "start", fmt.Sprintf("count=%d", len(vulnRows)))
	collections.SortByFields(vulnRows,
		func(x sql.BatchUpsertVulnerabilitiesParams) string { return x.ImageName },
		func(x sql.BatchUpsertVulnerabilitiesParams) string { return x.ImageTag },
	)
	vulnErrCount := 0
	p.Querier.BatchUpsertVulnerabilities(ctx, vulnRows).Exec(func(_ int, err error) {
		if err != nil {
			vulnErrCount++
			errs = append(errs, err)
		}
	})
	if vulnErrCount > 0 {
		rec.Add("upsert_vulns", "error", fmt.Sprintf("errors=%d", vulnErrCount))
	} else {
		rec.Add("upsert_vulns", "ok", "")
	}

	// Update image states
	rec.Add("update_image_states", "start", fmt.Sprintf("count=%d", len(imgStateRows)))
	collections.SortByFields(imgStateRows,
		func(x sql.BatchUpdateImageStateParams) string { return x.Name },
		func(x sql.BatchUpdateImageStateParams) string { return x.Tag },
	)
	stateErrCount := 0
	p.Querier.BatchUpdateImageState(ctx, imgStateRows).Exec(func(_ int, err error) {
		if err != nil {
			stateErrCount++
			errs = append(errs, err)
		}
	})
	if stateErrCount > 0 {
		rec.Add("update_image_states", "error", fmt.Sprintf("errors=%d", stateErrCount))
	} else {
		rec.Add("update_image_states", "ok", "")
	}

	// Enqueue vulnerability summary job
	rec.Add("enqueue_summaries", "start", fmt.Sprintf("images=%d", len(summaryImages)))
	if err := p.JobClient.AddJob(ctx, &job.UpsertVulnerabilitySummariesJob{
		Images: summaryImages,
	}); err != nil {
		rec.Add("enqueue_summaries", "error", err.Error())
		errs = append(errs, fmt.Errorf("enqueue summaries job: %w", err))
	} else {
		rec.Add("enqueue_summaries", "ok", "")
	}

	if len(errs) > 0 {
		rec.Add("finish", "error", fmt.Sprintf("errors=%d", len(errs)))
		return errors.Join(errs...)
	}

	rec.Add("finish", "success", "")
	return nil
}

func toVulnerabilitySqlParams(ctx context.Context, querier sql.Querier, i *sources.ImageVulnerabilityData) []sql.BatchUpsertVulnerabilitiesParams {
	params := make([]sql.BatchUpsertVulnerabilitiesParams, 0)
	for _, v := range i.Vulnerabilities {
		severity := v.Cve.Severity.ToInt32()
		severitySince, err := DetermineSeveritySince(ctx, querier, i.ImageName, v.Package, v.Cve.Id, severity)
		if err != nil {
			logrus.Errorf("determine severitySince: %v", err)
		}
		batch := sql.BatchUpsertVulnerabilitiesParams{
			ImageName:     i.ImageName,
			ImageTag:      i.ImageTag,
			Package:       v.Package,
			CveID:         v.Cve.Id,
			Source:        i.Source,
			LatestVersion: v.LatestVersion,
			LastSeverity:  severity,
		}

		if severitySince != nil {
			batch.SeveritySince = pgtype.Timestamptz{
				Time:  *severitySince,
				Valid: true,
			}
		}
		params = append(params, batch)
	}
	return params
}

func DetermineSeveritySince(
	ctx context.Context,
	querier sql.Querier,
	imageName, pkg, cveID string,
	lastSeverity int32,
) (*time.Time, error) {

	earliest, err := querier.GetEarliestSeveritySinceForVulnerability(ctx, sql.GetEarliestSeveritySinceForVulnerabilityParams{
		ImageName:    imageName,
		Package:      pkg,
		CveID:        cveID,
		LastSeverity: lastSeverity,
	})
	if err != nil {
		return nil, err
	}

	if earliest.Valid {
		t := earliest.Time.UTC()
		return &t, nil
	}

	now := time.Now().UTC()
	return &now, nil
}

func toCveSqlParams(batch *sources.ImageVulnerabilityData) []sql.BatchUpsertCveParams {
	params := make([]sql.BatchUpsertCveParams, 0)
	for _, v := range batch.Vulnerabilities {
		params = append(params, sql.BatchUpsertCveParams{
			CveID:    v.Cve.Id,
			CveTitle: v.Cve.Title,
			CveDesc:  v.Cve.Description,
			CveLink:  v.Cve.Link,
			Severity: v.Cve.Severity.ToInt32(),
			Refs:     v.Cve.References,
		})
	}
	return params
}
