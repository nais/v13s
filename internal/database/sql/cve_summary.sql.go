// Code generated by sqlc. DO NOT EDIT.
// source: cve_summary.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const listCveSummaries = `-- name: ListCveSummaries :many
WITH cve_data AS (
    SELECT
        c.cve_id, c.cve_title, c.cve_desc, c.cve_link, c.severity, c.refs, c.created_at, c.updated_at, c.cvss_score,
        COUNT(DISTINCT w.id)::INT AS affected_workloads
    FROM
        vulnerabilities v
        JOIN cve c ON v.cve_id = c.cve_id
        JOIN workloads w ON w.image_name = v.image_name
            AND w.image_tag = v.image_tag
        LEFT JOIN suppressed_vulnerabilities sv ON v.image_name = sv.image_name
            AND v.package = sv.package
            AND v.cve_id = sv.cve_id
    WHERE ($4::TEXT IS NULL
        OR w.cluster = $4::TEXT)
    AND ($5::TEXT IS NULL
        OR w.namespace = $5::TEXT)
    AND (cardinality($6::TEXT[]) = 0
        OR w.namespace <> ALL ($6::TEXT[]))
    AND ($7::TEXT IS NULL
        OR w.workload_type = $7::TEXT)
    AND ($8::TEXT IS NULL
        OR w.name = $8::TEXT)
    AND ($9::TEXT IS NULL
        OR v.image_name = $9::TEXT)
    AND ($10::TEXT IS NULL
        OR v.image_tag = $10::TEXT)
    AND (cardinality($11::TEXT[]) = 0
        OR w.cluster <> ALL ($11::TEXT[]))
GROUP BY
    c.cve_id
)
SELECT
    cve_id, cve_title, cve_desc, cve_link, severity, refs, created_at, updated_at, cvss_score, affected_workloads,
    COUNT(*) OVER ()::INT AS total_count
FROM
    cve_data
ORDER BY
    CASE WHEN $1 = 'cvss_score_desc' THEN
        CASE WHEN cvss_score = 0
            OR cvss_score IS NULL THEN
            1
        ELSE
            0
        END
    END ASC,
    CASE WHEN $1 = 'cvss_score_desc' THEN
        cvss_score
    END DESC,
    CASE WHEN $1 = 'cvss_score_asc' THEN
        cvss_score
    END ASC,
    CASE WHEN $1 = 'affected_workloads_desc' THEN
        affected_workloads
    END DESC,
    CASE WHEN $1 = 'affected_workloads_desc' THEN
        CASE WHEN cvss_score IS NULL
            OR cvss_score = 0 THEN
            1
        ELSE
            0
        END
    END ASC,
    CASE WHEN $1 = 'affected_workloads_desc' THEN
        cvss_score
    END DESC,
    CASE WHEN $1 = 'affected_workloads_asc' THEN
        affected_workloads
    END ASC,
    CASE WHEN $1 = 'cve_id_asc' THEN
        cve_id
    END ASC,
    CASE WHEN $1 = 'cve_id_desc' THEN
        cve_id
    END DESC,
    cve_id ASC
LIMIT $3
    OFFSET $2
`

type ListCveSummariesParams struct {
	OrderBy           interface{}
	Offset            int32
	Limit             int32
	Cluster           *string
	Namespace         *string
	ExcludeNamespaces []string
	WorkloadType      *string
	WorkloadName      *string
	ImageName         *string
	ImageTag          *string
	ExcludeClusters   []string
}

type ListCveSummariesRow struct {
	CveID             string
	CveTitle          string
	CveDesc           string
	CveLink           string
	Severity          int32
	Refs              []byte
	CreatedAt         pgtype.Timestamptz
	UpdatedAt         pgtype.Timestamptz
	CvssScore         *float64
	AffectedWorkloads int32
	TotalCount        int32
}

func (q *Queries) ListCveSummaries(ctx context.Context, arg ListCveSummariesParams) ([]*ListCveSummariesRow, error) {
	rows, err := q.db.Query(ctx, listCveSummaries,
		arg.OrderBy,
		arg.Offset,
		arg.Limit,
		arg.Cluster,
		arg.Namespace,
		arg.ExcludeNamespaces,
		arg.WorkloadType,
		arg.WorkloadName,
		arg.ImageName,
		arg.ImageTag,
		arg.ExcludeClusters,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListCveSummariesRow{}
	for rows.Next() {
		var i ListCveSummariesRow
		if err := rows.Scan(
			&i.CveID,
			&i.CveTitle,
			&i.CveDesc,
			&i.CveLink,
			&i.Severity,
			&i.Refs,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CvssScore,
			&i.AffectedWorkloads,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
