// Code generated by sqlc. DO NOT EDIT.
// source: workload_mttf.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const listMeanTimeToFixTrendBySeverity = `-- name: ListMeanTimeToFixTrendBySeverity :many
WITH mttr AS (
    SELECT
        v.severity,
        v.snapshot_date      AS snapshot_time,
        AVG(v.fix_duration)::INT AS mean_time_to_fix_days,
        COUNT(*)::INT        AS fixed_count,
        MIN(v.fixed_at)::date     AS first_fixed_at,
        MAX(v.fixed_at)::date      AS last_fixed_at
    FROM vuln_fix_summary v
             JOIN workloads w ON w.id = v.workload_id
    WHERE v.is_fixed = true
      AND ($1::TEXT IS NULL OR w.cluster = $1::TEXT)
      AND ($2::TEXT IS NULL OR w.namespace = $2::TEXT)
      AND ($3::TEXT[] IS NULL OR w.workload_type = ANY($3::TEXT[]))
      AND ($4::TEXT IS NULL OR w.name = $4::TEXT)
      AND (
        $5::timestamptz IS NULL
          OR (
              $6::TEXT = 'snapshot' AND v.snapshot_date >= $5::timestamptz
          )
          OR (
              $6::TEXT = 'fixed' AND v.fixed_at >= $5::timestamptz
          )
        )
    GROUP BY v.snapshot_date, v.severity
)
SELECT
    severity,
    snapshot_time,
    mean_time_to_fix_days,
    fixed_count,
    first_fixed_at,
    last_fixed_at
FROM mttr
ORDER BY snapshot_time, severity
`

type ListMeanTimeToFixTrendBySeverityParams struct {
	Cluster       *string
	Namespace     *string
	WorkloadTypes []string
	WorkloadName  *string
	Since         pgtype.Timestamptz
	SinceType     *string
}

type ListMeanTimeToFixTrendBySeverityRow struct {
	Severity          int32
	SnapshotTime      pgtype.Date
	MeanTimeToFixDays int32
	FixedCount        int32
	FirstFixedAt      pgtype.Date
	LastFixedAt       pgtype.Date
}

func (q *Queries) ListMeanTimeToFixTrendBySeverity(ctx context.Context, arg ListMeanTimeToFixTrendBySeverityParams) ([]*ListMeanTimeToFixTrendBySeverityRow, error) {
	rows, err := q.db.Query(ctx, listMeanTimeToFixTrendBySeverity,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadTypes,
		arg.WorkloadName,
		arg.Since,
		arg.SinceType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListMeanTimeToFixTrendBySeverityRow{}
	for rows.Next() {
		var i ListMeanTimeToFixTrendBySeverityRow
		if err := rows.Scan(
			&i.Severity,
			&i.SnapshotTime,
			&i.MeanTimeToFixDays,
			&i.FixedCount,
			&i.FirstFixedAt,
			&i.LastFixedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkloadSeverityFixStats = `-- name: ListWorkloadSeverityFixStats :many
SELECT
    v.workload_id,
    w.name AS workload_name,
    w.namespace AS workload_namespace,
    w.cluster AS workload_cluster,
    v.severity,
    MIN(v.introduced_at)::date AS introduced_date,
    MAX(v.fixed_at)::date AS fixed_at,
    COUNT(*) FILTER (WHERE v.is_fixed)::INT AS fixed_count,
    COALESCE(AVG((v.fixed_at::date - v.introduced_at::date)), 0)::INT AS mean_time_to_fix_days,
    MAX(v.snapshot_date)::timestamptz AS snapshot_time
FROM vuln_fix_summary v
         JOIN workloads w ON w.id = v.workload_id
WHERE
    ($1::TEXT IS NULL OR w.cluster = $1::TEXT)
  AND ($2::TEXT IS NULL OR w.namespace = $2::TEXT)
  AND ($3::TEXT[] IS NULL OR w.workload_type = ANY($3::TEXT[]))
  AND ($4::TEXT IS NULL OR w.name = $4::TEXT)
  AND (
    $5::timestamptz IS NULL
        OR (
            $6::TEXT = 'snapshot' AND v.snapshot_date >= $5::timestamptz
        )
        OR (
            $6::TEXT = 'fixed' AND v.fixed_at >= $5::timestamptz
        )
    )
GROUP BY v.workload_id, w.name, w.namespace, w.cluster, v.severity
ORDER BY introduced_date DESC
`

type ListWorkloadSeverityFixStatsParams struct {
	Cluster       *string
	Namespace     *string
	WorkloadTypes []string
	WorkloadName  *string
	Since         pgtype.Timestamptz
	SinceType     *string
}

type ListWorkloadSeverityFixStatsRow struct {
	WorkloadID        pgtype.UUID
	WorkloadName      string
	WorkloadNamespace string
	WorkloadCluster   string
	Severity          int32
	IntroducedDate    pgtype.Date
	FixedAt           pgtype.Date
	FixedCount        int32
	MeanTimeToFixDays int32
	SnapshotTime      pgtype.Timestamptz
}

func (q *Queries) ListWorkloadSeverityFixStats(ctx context.Context, arg ListWorkloadSeverityFixStatsParams) ([]*ListWorkloadSeverityFixStatsRow, error) {
	rows, err := q.db.Query(ctx, listWorkloadSeverityFixStats,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadTypes,
		arg.WorkloadName,
		arg.Since,
		arg.SinceType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListWorkloadSeverityFixStatsRow{}
	for rows.Next() {
		var i ListWorkloadSeverityFixStatsRow
		if err := rows.Scan(
			&i.WorkloadID,
			&i.WorkloadName,
			&i.WorkloadNamespace,
			&i.WorkloadCluster,
			&i.Severity,
			&i.IntroducedDate,
			&i.FixedAt,
			&i.FixedCount,
			&i.MeanTimeToFixDays,
			&i.SnapshotTime,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertVulnerabilityLifetimes = `-- name: UpsertVulnerabilityLifetimes :exec
INSERT INTO vuln_fix_summary (
    workload_id,
    severity,
    introduced_at,
    fixed_at,
    fix_duration,
    is_fixed,
    snapshot_date
)
SELECT
    workload_id,
    severity,
    introduced_at,
    fixed_at,
    fix_duration,
    is_fixed,
    snapshot_date
FROM vuln_upsert_data_for_date(CURRENT_DATE) ON CONFLICT (workload_id, severity, introduced_at, snapshot_date) DO
UPDATE
    SET
        fixed_at = EXCLUDED.fixed_at,
    fix_duration = EXCLUDED.fix_duration,
    is_fixed = EXCLUDED.is_fixed
`

func (q *Queries) UpsertVulnerabilityLifetimes(ctx context.Context) error {
	_, err := q.db.Exec(ctx, upsertVulnerabilityLifetimes)
	return err
}
