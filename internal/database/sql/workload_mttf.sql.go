// Code generated by sqlc. DO NOT EDIT.
// source: workload_mttf.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const listMeanTimeToFixTrendBySeverity = `-- name: ListMeanTimeToFixTrendBySeverity :many
WITH mttr AS (
    SELECT
        v.severity,
        v.snapshot_date      AS snapshot_time,
        AVG(v.fix_duration)::INT AS mean_time_to_fix_days,
        COUNT(*)::INT        AS fixed_count,
        MIN(v.fixed_at)::timestamptz     AS first_fixed_at,
        MAX(v.fixed_at)::timestamptz      AS last_fixed_at
    FROM vuln_fix_summary v
             JOIN workloads w ON w.id = v.workload_id
    WHERE v.is_fixed = true
      AND ($1::TEXT IS NULL OR w.cluster = $1::TEXT)
      AND ($2::TEXT IS NULL OR w.namespace = $2::TEXT)
      AND ($3::TEXT[] IS NULL OR w.workload_type = ANY($3::TEXT[]))
      AND ($4::TEXT IS NULL OR w.name = $4::TEXT)
      AND ($5::timestamptz IS NULL OR v.fixed_at >= $5::timestamptz)
    GROUP BY v.snapshot_date, v.severity
)
SELECT
    severity,
    snapshot_time,
    mean_time_to_fix_days,
    fixed_count,
    first_fixed_at,
    last_fixed_at
FROM mttr
ORDER BY snapshot_time, severity
`

type ListMeanTimeToFixTrendBySeverityParams struct {
	Cluster       *string
	Namespace     *string
	WorkloadTypes []string
	WorkloadName  *string
	Since         pgtype.Timestamptz
}

type ListMeanTimeToFixTrendBySeverityRow struct {
	Severity          int32
	SnapshotTime      pgtype.Date
	MeanTimeToFixDays int32
	FixedCount        int32
	FirstFixedAt      pgtype.Timestamptz
	LastFixedAt       pgtype.Timestamptz
}

func (q *Queries) ListMeanTimeToFixTrendBySeverity(ctx context.Context, arg ListMeanTimeToFixTrendBySeverityParams) ([]*ListMeanTimeToFixTrendBySeverityRow, error) {
	rows, err := q.db.Query(ctx, listMeanTimeToFixTrendBySeverity,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadTypes,
		arg.WorkloadName,
		arg.Since,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListMeanTimeToFixTrendBySeverityRow{}
	for rows.Next() {
		var i ListMeanTimeToFixTrendBySeverityRow
		if err := rows.Scan(
			&i.Severity,
			&i.SnapshotTime,
			&i.MeanTimeToFixDays,
			&i.FixedCount,
			&i.FirstFixedAt,
			&i.LastFixedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkloadSeverityFixStats = `-- name: ListWorkloadSeverityFixStats :many
SELECT
    v.workload_id,
    w.name       AS workload_name,
    w.namespace  AS workload_namespace,
    w.cluster    AS workload_cluster,
    v.severity,
    MIN(v.introduced_at)::date AS introduced_date,
    MAX(v.fixed_at)::date AS fixed_at,
    COUNT(*) FILTER (WHERE v.is_fixed)::INT AS fixed_count,
    COALESCE(AVG((v.fixed_at::date - v.introduced_at::date)), 0)::INT mean_time_to_fix_days,
    MAX(v.snapshot_date)::timestamptz AS snapshot_time
FROM vuln_fix_summary v
         JOIN workloads w ON w.id = v.workload_id
WHERE (
          ($1::TEXT IS NULL OR w.cluster = $1::TEXT)
              AND ($2::TEXT IS NULL OR w.namespace = $2::TEXT)
              AND ($3::TEXT[] IS NULL OR w.workload_type = ANY($3::TEXT[]))
              AND ($4::TEXT IS NULL OR w.name = $4::TEXT)
          )
GROUP BY v.workload_id, w.name, w.namespace, w.cluster, v.severity
ORDER BY introduced_date DESC
`

type ListWorkloadSeverityFixStatsParams struct {
	Cluster       *string
	Namespace     *string
	WorkloadTypes []string
	WorkloadName  *string
}

type ListWorkloadSeverityFixStatsRow struct {
	WorkloadID        pgtype.UUID
	WorkloadName      string
	WorkloadNamespace string
	WorkloadCluster   string
	Severity          int32
	IntroducedDate    pgtype.Date
	FixedAt           pgtype.Date
	FixedCount        int32
	MeanTimeToFixDays int32
	SnapshotTime      pgtype.Timestamptz
}

func (q *Queries) ListWorkloadSeverityFixStats(ctx context.Context, arg ListWorkloadSeverityFixStatsParams) ([]*ListWorkloadSeverityFixStatsRow, error) {
	rows, err := q.db.Query(ctx, listWorkloadSeverityFixStats,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadTypes,
		arg.WorkloadName,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListWorkloadSeverityFixStatsRow{}
	for rows.Next() {
		var i ListWorkloadSeverityFixStatsRow
		if err := rows.Scan(
			&i.WorkloadID,
			&i.WorkloadName,
			&i.WorkloadNamespace,
			&i.WorkloadCluster,
			&i.Severity,
			&i.IntroducedDate,
			&i.FixedAt,
			&i.FixedCount,
			&i.MeanTimeToFixDays,
			&i.SnapshotTime,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertVulnerabilityLifetimes = `-- name: UpsertVulnerabilityLifetimes :exec
INSERT INTO vuln_fix_summary (
    workload_id,
    severity,
    introduced_at,
    fixed_at,
    fix_duration,
    is_fixed,
    snapshot_date
)
SELECT
    v.workload_id,
    v.severity,
    v.introduced_at,
    v.fixed_at,
    v.fix_duration,
    v.is_fixed,
    v.snapshot_date
FROM vuln_upsert_data v
         JOIN workloads w ON w.id = v.workload_id
    ON CONFLICT (workload_id, severity, introduced_at) DO
UPDATE
    SET
        fixed_at = EXCLUDED.fixed_at,
    fix_duration = EXCLUDED.fix_duration,
    is_fixed = EXCLUDED.is_fixed,
    snapshot_date = EXCLUDED.snapshot_date
`

func (q *Queries) UpsertVulnerabilityLifetimes(ctx context.Context) error {
	_, err := q.db.Exec(ctx, upsertVulnerabilityLifetimes)
	return err
}
