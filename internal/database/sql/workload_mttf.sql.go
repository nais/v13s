// Code generated by sqlc. DO NOT EDIT.
// source: workload_mttf.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const listMeanTimeToFixTrendBySeverity = `-- name: ListMeanTimeToFixTrendBySeverity :many
WITH filtered AS (
    SELECT
        v.severity,
        v.snapshot_date,
        v.fix_duration,
        v.fixed_at,
        v.introduced_at,
        v.workload_id
    FROM
        vuln_fix_summary v
        JOIN workloads w ON w.id = v.workload_id
    WHERE
        v.is_fixed = TRUE
        AND ($1::TEXT IS NULL
            OR w.cluster = $1::TEXT)
        AND ($2::TEXT IS NULL
            OR w.namespace = $2::TEXT)
        AND ($3::TEXT[] IS NULL
            OR w.workload_type = ANY ($3::TEXT[]))
        AND ($4::TEXT IS NULL
            OR w.name = $4::TEXT)
        AND ($5::TIMESTAMPTZ IS NULL
            OR (
                CASE COALESCE($6::TEXT, 'snapshot')
                WHEN 'snapshot' THEN
                    v.snapshot_date
                WHEN 'fixed' THEN
                    v.fixed_at
                END >= $5::TIMESTAMPTZ))
),
aggregated AS (
    SELECT
        f.severity,
        f.snapshot_date,
        AVG(f.fix_duration)::INT AS mean_time_to_fix_days,
        COUNT(*)::INT AS fixed_count,
        MIN(f.fixed_at)::DATE AS first_fixed_at,
        MAX(f.fixed_at)::DATE AS last_fixed_at,
        COUNT(DISTINCT f.workload_id)::INT AS registered_workloads
    FROM ( SELECT DISTINCT
            severity,
            workload_id,
            introduced_at,
            fix_duration,
            fixed_at,
            snapshot_date
        FROM
            filtered) f
    GROUP BY
        f.snapshot_date,
        f.severity
)
SELECT
    severity,
    snapshot_date,
    mean_time_to_fix_days,
    fixed_count,
    registered_workloads,
    first_fixed_at,
    last_fixed_at
FROM
    aggregated
ORDER BY
    snapshot_date,
    severity
`

type ListMeanTimeToFixTrendBySeverityParams struct {
	Cluster       *string
	Namespace     *string
	WorkloadTypes []string
	WorkloadName  *string
	Since         pgtype.Timestamptz
	SinceType     *string
}

type ListMeanTimeToFixTrendBySeverityRow struct {
	Severity            int32
	SnapshotDate        pgtype.Date
	MeanTimeToFixDays   int32
	FixedCount          int32
	RegisteredWorkloads int32
	FirstFixedAt        pgtype.Date
	LastFixedAt         pgtype.Date
}

func (q *Queries) ListMeanTimeToFixTrendBySeverity(ctx context.Context, arg ListMeanTimeToFixTrendBySeverityParams) ([]*ListMeanTimeToFixTrendBySeverityRow, error) {
	rows, err := q.db.Query(ctx, listMeanTimeToFixTrendBySeverity,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadTypes,
		arg.WorkloadName,
		arg.Since,
		arg.SinceType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListMeanTimeToFixTrendBySeverityRow{}
	for rows.Next() {
		var i ListMeanTimeToFixTrendBySeverityRow
		if err := rows.Scan(
			&i.Severity,
			&i.SnapshotDate,
			&i.MeanTimeToFixDays,
			&i.FixedCount,
			&i.RegisteredWorkloads,
			&i.FirstFixedAt,
			&i.LastFixedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkloadSeverityFixStats = `-- name: ListWorkloadSeverityFixStats :many
WITH filtered AS (
    SELECT DISTINCT
        v.severity,
        v.workload_id,
        v.introduced_at,
        v.fixed_at,
        v.snapshot_date,
        v.is_fixed
    FROM
        vuln_fix_summary v
        JOIN workloads w ON w.id = v.workload_id
    WHERE ($1::TEXT IS NULL
        OR w.cluster = $1::TEXT)
    AND ($2::TEXT IS NULL
        OR w.namespace = $2::TEXT)
    AND ($3::TEXT[] IS NULL
        OR w.workload_type = ANY ($3::TEXT[]))
    AND ($4::TEXT IS NULL
        OR w.name = $4::TEXT)
    AND ($5::TIMESTAMPTZ IS NULL
        OR (
            CASE COALESCE($6::TEXT, 'snapshot')
            WHEN 'snapshot' THEN
                v.snapshot_date
            WHEN 'fixed' THEN
                v.fixed_at
            END >= $5::TIMESTAMPTZ)))
SELECT
    f.workload_id,
    w.name AS workload_name,
    w.namespace AS workload_namespace,
    f.severity,
    MIN(f.introduced_at)::DATE AS introduced_date,
    MAX(f.fixed_at)::DATE AS fixed_at,
    COUNT(*) FILTER (WHERE f.is_fixed)::INT AS fixed_count,
    COALESCE(AVG(f.fixed_at::DATE - f.introduced_at::DATE), 0)::INT AS mean_time_to_fix_days,
    MAX(f.snapshot_date)::TIMESTAMPTZ AS snapshot_date
FROM
    filtered f
    JOIN workloads w ON w.id = f.workload_id
GROUP BY
    f.workload_id,
    w.name,
    w.namespace,
    f.severity
ORDER BY
    introduced_date DESC
`

type ListWorkloadSeverityFixStatsParams struct {
	Cluster       *string
	Namespace     *string
	WorkloadTypes []string
	WorkloadName  *string
	Since         pgtype.Timestamptz
	SinceType     *string
}

type ListWorkloadSeverityFixStatsRow struct {
	WorkloadID        pgtype.UUID
	WorkloadName      string
	WorkloadNamespace string
	Severity          int32
	IntroducedDate    pgtype.Date
	FixedAt           pgtype.Date
	FixedCount        int32
	MeanTimeToFixDays int32
	SnapshotDate      pgtype.Timestamptz
}

func (q *Queries) ListWorkloadSeverityFixStats(ctx context.Context, arg ListWorkloadSeverityFixStatsParams) ([]*ListWorkloadSeverityFixStatsRow, error) {
	rows, err := q.db.Query(ctx, listWorkloadSeverityFixStats,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadTypes,
		arg.WorkloadName,
		arg.Since,
		arg.SinceType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListWorkloadSeverityFixStatsRow{}
	for rows.Next() {
		var i ListWorkloadSeverityFixStatsRow
		if err := rows.Scan(
			&i.WorkloadID,
			&i.WorkloadName,
			&i.WorkloadNamespace,
			&i.Severity,
			&i.IntroducedDate,
			&i.FixedAt,
			&i.FixedCount,
			&i.MeanTimeToFixDays,
			&i.SnapshotDate,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertVulnerabilityLifetimes = `-- name: UpsertVulnerabilityLifetimes :exec
INSERT INTO vuln_fix_summary(
    workload_id,
    severity,
    introduced_at,
    fixed_at,
    fix_duration,
    is_fixed,
    snapshot_date)
SELECT
    v.workload_id,
    v.severity,
    v.introduced_at,
    v.fixed_at,
    v.fix_duration,
    v.is_fixed,
    v.snapshot_date
FROM
    vuln_upsert_data_for_date(CURRENT_DATE) v
WHERE
    v.workload_id IN (
        SELECT
            id
        FROM
            workloads)
ON CONFLICT (workload_id,
    severity,
    introduced_at,
    snapshot_date)
    DO UPDATE SET
        fixed_at = EXCLUDED.fixed_at,
        fix_duration = EXCLUDED.fix_duration,
        is_fixed = EXCLUDED.is_fixed
`

func (q *Queries) UpsertVulnerabilityLifetimes(ctx context.Context) error {
	_, err := q.db.Exec(ctx, upsertVulnerabilityLifetimes)
	return err
}
