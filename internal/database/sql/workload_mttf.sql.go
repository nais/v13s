// Code generated by sqlc. DO NOT EDIT.
// source: workload_mttf.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const listMeanTimeToFixTrendBySeverity = `-- name: ListMeanTimeToFixTrendBySeverity :many
WITH filtered AS (
    SELECT
        v.severity,
        v.snapshot_date,
        v.fix_duration,
        v.fixed_at,
        v.introduced_at,
        v.workload_id
    FROM vuln_fix_summary v
             JOIN workloads w ON w.id = v.workload_id
    WHERE v.is_fixed = true
      AND ($1::TEXT IS NULL OR w.cluster = $1::TEXT)
      AND ($2::TEXT IS NULL OR w.namespace = $2::TEXT)
      AND ($3::TEXT[] IS NULL OR w.workload_type = ANY($3::TEXT[]))
      AND ($4::TEXT IS NULL OR w.name = $4::TEXT)
      AND (
        $5::timestamptz IS NULL
          OR (
              CASE COALESCE($6::TEXT, 'snapshot')
                  WHEN 'snapshot' THEN v.snapshot_date
                  WHEN 'fixed' THEN v.fixed_at
              END >= $5::timestamptz
          )
        )
),
     aggregated AS (
         SELECT
             f.severity,
             f.snapshot_date,
             AVG(f.fix_duration)::INT AS mean_time_to_fix_days,
             COUNT(*)::INT AS fixed_count,
             MIN(f.fixed_at)::date AS first_fixed_at,
             MAX(f.fixed_at)::date AS last_fixed_at,
             COUNT(DISTINCT f.workload_id)::INT AS registered_workloads
         FROM (
                  SELECT DISTINCT severity, workload_id, introduced_at, fix_duration, fixed_at, snapshot_date
                  FROM filtered
              ) f
         GROUP BY f.snapshot_date, f.severity
     )
SELECT
    severity,
    snapshot_date,
    mean_time_to_fix_days,
    fixed_count,
    registered_workloads,
    first_fixed_at,
    last_fixed_at
FROM aggregated
ORDER BY snapshot_date, severity
`

type ListMeanTimeToFixTrendBySeverityParams struct {
	Cluster       *string
	Namespace     *string
	WorkloadTypes []string
	WorkloadName  *string
	Since         pgtype.Timestamptz
	SinceType     *string
}

type ListMeanTimeToFixTrendBySeverityRow struct {
	Severity            int32
	SnapshotDate        pgtype.Date
	MeanTimeToFixDays   int32
	FixedCount          int32
	RegisteredWorkloads int32
	FirstFixedAt        pgtype.Date
	LastFixedAt         pgtype.Date
}

func (q *Queries) ListMeanTimeToFixTrendBySeverity(ctx context.Context, arg ListMeanTimeToFixTrendBySeverityParams) ([]*ListMeanTimeToFixTrendBySeverityRow, error) {
	rows, err := q.db.Query(ctx, listMeanTimeToFixTrendBySeverity,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadTypes,
		arg.WorkloadName,
		arg.Since,
		arg.SinceType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListMeanTimeToFixTrendBySeverityRow{}
	for rows.Next() {
		var i ListMeanTimeToFixTrendBySeverityRow
		if err := rows.Scan(
			&i.Severity,
			&i.SnapshotDate,
			&i.MeanTimeToFixDays,
			&i.FixedCount,
			&i.RegisteredWorkloads,
			&i.FirstFixedAt,
			&i.LastFixedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkloadSeverityFixStats = `-- name: ListWorkloadSeverityFixStats :many
WITH filtered AS (
    SELECT DISTINCT
        v.severity,
        v.workload_id,
        v.introduced_at,
        v.fixed_at,
        v.snapshot_date,
        v.is_fixed
    FROM vuln_fix_summary v
             JOIN workloads w ON w.id = v.workload_id
    WHERE
        ($1::TEXT IS NULL OR w.cluster = $1::TEXT)
      AND ($2::TEXT IS NULL OR w.namespace = $2::TEXT)
      AND ($3::TEXT[] IS NULL OR w.workload_type = ANY($3::TEXT[]))
      AND ($4::TEXT IS NULL OR w.name = $4::TEXT)
      AND (
        $5::timestamptz IS NULL
        OR (
            CASE COALESCE($6::TEXT, 'snapshot')
                WHEN 'snapshot' THEN v.snapshot_date
                WHEN 'fixed' THEN v.fixed_at
            END >= $5::timestamptz
        )
        )
)
SELECT
    f.workload_id,
    w.name AS workload_name,
    w.namespace AS workload_namespace,
    f.severity,
    MIN(f.introduced_at)::date AS introduced_date,
    MAX(f.fixed_at)::date AS fixed_at,
    COUNT(*) FILTER (WHERE f.is_fixed)::INT AS fixed_count,
    COALESCE(AVG((f.fixed_at::date - f.introduced_at::date)), 0)::INT AS mean_time_to_fix_days,
    MAX(f.snapshot_date)::timestamptz as snapshot_date
FROM filtered f
         JOIN workloads w ON w.id = f.workload_id
GROUP BY f.workload_id, w.name, w.namespace, f.severity
ORDER BY introduced_date DESC
`

type ListWorkloadSeverityFixStatsParams struct {
	Cluster       *string
	Namespace     *string
	WorkloadTypes []string
	WorkloadName  *string
	Since         pgtype.Timestamptz
	SinceType     *string
}

type ListWorkloadSeverityFixStatsRow struct {
	WorkloadID        pgtype.UUID
	WorkloadName      string
	WorkloadNamespace string
	Severity          int32
	IntroducedDate    pgtype.Date
	FixedAt           pgtype.Date
	FixedCount        int32
	MeanTimeToFixDays int32
	SnapshotDate      pgtype.Timestamptz
}

func (q *Queries) ListWorkloadSeverityFixStats(ctx context.Context, arg ListWorkloadSeverityFixStatsParams) ([]*ListWorkloadSeverityFixStatsRow, error) {
	rows, err := q.db.Query(ctx, listWorkloadSeverityFixStats,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadTypes,
		arg.WorkloadName,
		arg.Since,
		arg.SinceType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListWorkloadSeverityFixStatsRow{}
	for rows.Next() {
		var i ListWorkloadSeverityFixStatsRow
		if err := rows.Scan(
			&i.WorkloadID,
			&i.WorkloadName,
			&i.WorkloadNamespace,
			&i.Severity,
			&i.IntroducedDate,
			&i.FixedAt,
			&i.FixedCount,
			&i.MeanTimeToFixDays,
			&i.SnapshotDate,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertVulnerabilityLifetimes = `-- name: UpsertVulnerabilityLifetimes :exec
INSERT INTO vuln_fix_summary (
    workload_id,
    severity,
    introduced_at,
    fixed_at,
    fix_duration,
    is_fixed,
    snapshot_date
)
SELECT
    v.workload_id,
    v.severity,
    v.introduced_at,
    v.fixed_at,
    v.fix_duration,
    v.is_fixed,
    v.snapshot_date
FROM vuln_upsert_data_for_date(CURRENT_DATE) v
WHERE v.workload_id IN (SELECT id FROM workloads)
    ON CONFLICT (workload_id, severity, introduced_at, snapshot_date)
DO UPDATE
           SET
               fixed_at = EXCLUDED.fixed_at,
           fix_duration = EXCLUDED.fix_duration,
           is_fixed = EXCLUDED.is_fixed
`

func (q *Queries) UpsertVulnerabilityLifetimes(ctx context.Context) error {
	_, err := q.db.Exec(ctx, upsertVulnerabilityLifetimes)
	return err
}
