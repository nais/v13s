// Code generated by sqlc. DO NOT EDIT.
// source: workload_vulnerabilities.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countWorkloadVulnerabilities = `-- name: CountWorkloadVulnerabilities :one
SELECT COUNT(*) AS total
FROM workload_vulnerabilities v
         JOIN workloads w ON v.workload_id = w.id
         LEFT JOIN suppressed_vulnerabilities sv
                   ON v.vulnerability_id = sv.id
WHERE (CASE WHEN $1::TEXT IS NOT NULL THEN w.cluster = $1::TEXT ELSE TRUE END)
  AND (CASE WHEN $2::TEXT IS NOT NULL THEN w.namespace = $2::TEXT ELSE TRUE END)
  AND (CASE WHEN $3::TEXT IS NOT NULL THEN w.workload_type = $3::TEXT ELSE TRUE END)
  AND (CASE WHEN $4::TEXT IS NOT NULL THEN w.name = $4::TEXT ELSE TRUE END)
  AND ($5::BOOLEAN IS TRUE OR COALESCE(sv.suppressed, FALSE) = FALSE)
`

type CountWorkloadVulnerabilitiesParams struct {
	Cluster           *string
	Namespace         *string
	WorkloadType      *string
	WorkloadName      *string
	IncludeSuppressed *bool
}

func (q *Queries) CountWorkloadVulnerabilities(ctx context.Context, arg CountWorkloadVulnerabilitiesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countWorkloadVulnerabilities,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadType,
		arg.WorkloadName,
		arg.IncludeSuppressed,
	)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const listWorkloadVulnerabilitiesBecameCriticalSince = `-- name: ListWorkloadVulnerabilitiesBecameCriticalSince :many
SELECT
    w.id AS workload_id,
    w.name AS workload_name,
    w.workload_type,
    w.namespace,
    w.cluster,
    w.image_name,
    w.image_tag,
    v.cve_id,
    v.package,
    wv.became_critical_at,
    wv.resolved_at,
    wv.created_at,
    v.last_severity,
    COALESCE(sv.suppressed, FALSE) AS suppressed,
    sv.reason,
    sv.reason_text,
    sv.suppressed_by,
    sv.updated_at AS suppressed_at
FROM workload_vulnerabilities wv
         JOIN workloads w ON wv.workload_id = w.id
         JOIN vulnerabilities v ON wv.vulnerability_id = v.id
         LEFT JOIN suppressed_vulnerabilities sv
                   ON v.image_name = sv.image_name
                       AND v.package    = sv.package
                       AND v.cve_id     = sv.cve_id
WHERE (CASE WHEN $1::TEXT IS NOT NULL THEN w.cluster = $1::TEXT ELSE TRUE END)
  AND (CASE WHEN $2::TEXT IS NOT NULL THEN w.namespace = $2::TEXT ELSE TRUE END)
  AND (CASE WHEN $3::TEXT IS NOT NULL THEN w.workload_type = $3::TEXT ELSE TRUE END)
  AND (CASE WHEN $4::TEXT IS NOT NULL THEN w.name = $4::TEXT ELSE TRUE END)
  AND ($5::BOOLEAN IS TRUE OR COALESCE(sv.suppressed, FALSE) = FALSE)
  AND ($6::BOOLEAN IS TRUE OR wv.resolved_at IS NULL)
  AND ($7::timestamptz IS NULL OR wv.became_critical_at > $7::timestamptz)
ORDER BY w.id, v.cve_id, v.package
    LIMIT $9
OFFSET $8
`

type ListWorkloadVulnerabilitiesBecameCriticalSinceParams struct {
	Cluster           *string
	Namespace         *string
	WorkloadType      *string
	WorkloadName      *string
	IncludeSuppressed *bool
	IncludeUnresolved *bool
	Since             pgtype.Timestamptz
	Offset            int32
	Limit             int32
}

type ListWorkloadVulnerabilitiesBecameCriticalSinceRow struct {
	WorkloadID       pgtype.UUID
	WorkloadName     string
	WorkloadType     string
	Namespace        string
	Cluster          string
	ImageName        string
	ImageTag         string
	CveID            string
	Package          string
	BecameCriticalAt pgtype.Timestamptz
	ResolvedAt       pgtype.Timestamptz
	CreatedAt        pgtype.Timestamptz
	LastSeverity     int32
	Suppressed       bool
	Reason           NullVulnerabilitySuppressReason
	ReasonText       *string
	SuppressedBy     *string
	SuppressedAt     pgtype.Timestamptz
}

func (q *Queries) ListWorkloadVulnerabilitiesBecameCriticalSince(ctx context.Context, arg ListWorkloadVulnerabilitiesBecameCriticalSinceParams) ([]*ListWorkloadVulnerabilitiesBecameCriticalSinceRow, error) {
	rows, err := q.db.Query(ctx, listWorkloadVulnerabilitiesBecameCriticalSince,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadType,
		arg.WorkloadName,
		arg.IncludeSuppressed,
		arg.IncludeUnresolved,
		arg.Since,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListWorkloadVulnerabilitiesBecameCriticalSinceRow{}
	for rows.Next() {
		var i ListWorkloadVulnerabilitiesBecameCriticalSinceRow
		if err := rows.Scan(
			&i.WorkloadID,
			&i.WorkloadName,
			&i.WorkloadType,
			&i.Namespace,
			&i.Cluster,
			&i.ImageName,
			&i.ImageTag,
			&i.CveID,
			&i.Package,
			&i.BecameCriticalAt,
			&i.ResolvedAt,
			&i.CreatedAt,
			&i.LastSeverity,
			&i.Suppressed,
			&i.Reason,
			&i.ReasonText,
			&i.SuppressedBy,
			&i.SuppressedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkloadsMeanHoursToFixCriticalVulns = `-- name: ListWorkloadsMeanHoursToFixCriticalVulns :many
WITH filtered_workloads AS (
    SELECT id, name, workload_type, namespace, cluster, image_name, image_tag, created_at, updated_at, state
    FROM workloads w
    WHERE ($4::TEXT IS NULL OR w.cluster = $4::TEXT)
      AND ($5::TEXT IS NULL OR w.namespace = $5::TEXT)
      AND ($6::TEXT IS NULL OR w.workload_type = $6::TEXT)
      AND ($7::TEXT IS NULL OR w.name = $7::TEXT)
),
     mhtf AS (
         SELECT
             wv.workload_id,
             AVG(EXTRACT(EPOCH FROM (wv.resolved_at - wv.became_critical_at)) / 3600.0)::double precision AS mean_hours_to_fix
FROM workload_vulnerabilities wv
    JOIN filtered_workloads fw ON wv.workload_id = fw.id
WHERE wv.became_critical_at IS NOT NULL
  AND wv.resolved_at IS NOT NULL
GROUP BY wv.workload_id
    )
SELECT
    w.id,
    w.name AS workload_name,
    w.workload_type,
    w.namespace,
    w.cluster,
    w.state AS workload_state,
    w.updated_at AS workload_updated_at,
    i.name AS image_name,
    i.tag AS image_tag,
    i.state AS image_state,
    i.updated_at AS image_updated_at,
    COALESCE(m.mean_hours_to_fix, 0) AS mean_hours_to_fix
FROM filtered_workloads w
         JOIN images i ON w.image_name = i.name AND w.image_tag = i.tag
         LEFT JOIN mhtf m ON w.id = m.workload_id
ORDER BY
    CASE WHEN $1 = 'workload_asc' THEN w.name END ASC,
    CASE WHEN $1 = 'workload_desc' THEN w.name END DESC,
    CASE WHEN $1 = 'namespace_asc' THEN w.namespace END ASC,
    CASE WHEN $1 = 'namespace_desc' THEN w.namespace END DESC,
    CASE WHEN $1 = 'cluster_asc' THEN w.cluster END ASC,
    CASE WHEN $1 = 'cluster_desc' THEN w.cluster END DESC,
    w.id ASC LIMIT $3
OFFSET $2
`

type ListWorkloadsMeanHoursToFixCriticalVulnsParams struct {
	OrderBy      interface{}
	Offset       int32
	Limit        int32
	Cluster      *string
	Namespace    *string
	WorkloadType *string
	WorkloadName *string
}

type ListWorkloadsMeanHoursToFixCriticalVulnsRow struct {
	ID                pgtype.UUID
	WorkloadName      string
	WorkloadType      string
	Namespace         string
	Cluster           string
	WorkloadState     WorkloadState
	WorkloadUpdatedAt pgtype.Timestamptz
	ImageName         string
	ImageTag          string
	ImageState        ImageState
	ImageUpdatedAt    pgtype.Timestamptz
	MeanHoursToFix    float64
}

func (q *Queries) ListWorkloadsMeanHoursToFixCriticalVulns(ctx context.Context, arg ListWorkloadsMeanHoursToFixCriticalVulnsParams) ([]*ListWorkloadsMeanHoursToFixCriticalVulnsRow, error) {
	rows, err := q.db.Query(ctx, listWorkloadsMeanHoursToFixCriticalVulns,
		arg.OrderBy,
		arg.Offset,
		arg.Limit,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadType,
		arg.WorkloadName,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListWorkloadsMeanHoursToFixCriticalVulnsRow{}
	for rows.Next() {
		var i ListWorkloadsMeanHoursToFixCriticalVulnsRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkloadName,
			&i.WorkloadType,
			&i.Namespace,
			&i.Cluster,
			&i.WorkloadState,
			&i.WorkloadUpdatedAt,
			&i.ImageName,
			&i.ImageTag,
			&i.ImageState,
			&i.ImageUpdatedAt,
			&i.MeanHoursToFix,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resolveWorkloadVulnerabilitiesForImage = `-- name: ResolveWorkloadVulnerabilitiesForImage :exec
UPDATE workload_vulnerabilities wv
SET resolved_at = NOW()
    FROM workloads w
WHERE wv.workload_id = w.id
  AND wv.vulnerability_id NOT IN (
    SELECT v.id
    FROM vulnerabilities v
    WHERE v.image_name = w.image_name
  AND v.image_tag = w.image_tag
    )
  AND wv.resolved_at IS NULL
  AND w.image_name = $1
  AND w.image_tag  = $2
`

type ResolveWorkloadVulnerabilitiesForImageParams struct {
	ImageName string
	ImageTag  string
}

func (q *Queries) ResolveWorkloadVulnerabilitiesForImage(ctx context.Context, arg ResolveWorkloadVulnerabilitiesForImageParams) error {
	_, err := q.db.Exec(ctx, resolveWorkloadVulnerabilitiesForImage, arg.ImageName, arg.ImageTag)
	return err
}

const syncWorkloadVulnerabilitiesForImage = `-- name: SyncWorkloadVulnerabilitiesForImage :exec
INSERT INTO workload_vulnerabilities (
    workload_id,
    vulnerability_id,
    created_at,
    became_critical_at
)
SELECT
    w.id,
    v.id,
    COALESCE($3, now()) AS created_at,
    CASE
        WHEN v.last_severity = 0 THEN COALESCE($3, now())
        ELSE NULL
        END AS became_critical_at
FROM workloads w
         JOIN vulnerabilities v
              ON w.image_name = v.image_name
                  AND w.image_tag = v.image_tag
         LEFT JOIN workload_vulnerabilities wv
                   ON wv.workload_id = w.id
                       AND wv.vulnerability_id = v.id
WHERE wv.id IS NULL
  AND v.last_severity = 0
  AND w.image_name = $1
  AND w.image_tag = $2
`

type SyncWorkloadVulnerabilitiesForImageParams struct {
	ImageName string
	ImageTag  string
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) SyncWorkloadVulnerabilitiesForImage(ctx context.Context, arg SyncWorkloadVulnerabilitiesForImageParams) error {
	_, err := q.db.Exec(ctx, syncWorkloadVulnerabilitiesForImage, arg.ImageName, arg.ImageTag, arg.CreatedAt)
	return err
}
