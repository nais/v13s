// Code generated by sqlc. DO NOT EDIT.
// source: status.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const listJobsForWorkload = `-- name: ListJobsForWorkload :many
WITH matched_workloads AS (
    SELECT
        w.id,
        w.name,
        w.workload_type,
        w.namespace,
        w.cluster,
        w.image_name,
        w.image_tag
    FROM workloads w
    WHERE
        ($1::TEXT IS NULL OR cluster = $1::TEXT)
      AND ($2::TEXT IS NULL OR namespace = $2::TEXT)
      AND ($3::TEXT[] IS NULL OR workload_type = ANY($3::TEXT[]))
      AND ($4::TEXT IS NULL OR name = $4::TEXT)
),
     filtered_jobs AS (
         SELECT DISTINCT
             rj.id,
             rj.kind,
             rj.state,
             rj.metadata,
             rj.errors,
             rj.finalized_at,
             rj.attempt
         FROM river_job rj
                  JOIN matched_workloads w ON (
             (rj.kind = 'add_workload' AND
              rj.args #>> '{Workload,Name}' = w.name AND
         rj.args #>> '{Workload,WorkloadType}' = w.workload_type AND
         rj.args #>> '{Workload,Namespace}' = w.namespace AND
         rj.args #>> '{Workload,Cluster}' = w.cluster)
                 OR
             (rj.kind IN ('get_attestation', 'upload_attestation') AND
              rj.args #>> '{ImageName}' = w.image_name AND
         rj.args #>> '{ImageTag}' = w.image_tag)
             )
     ),
     total_count AS (
         SELECT COUNT(*) AS total FROM filtered_jobs
     ),
     paged_jobs AS (
         SELECT id, kind, state, metadata, errors, finalized_at, attempt
         FROM filtered_jobs
         ORDER BY id DESC
    LIMIT $6 OFFSET $5
    )
SELECT
    pj.id AS job_id,
    pj.kind AS job_kind,
    pj.state AS job_state,
    CASE WHEN pj.metadata::TEXT IS NOT NULL THEN pj.metadata::TEXT END AS job_metadata,
    CASE WHEN pj.errors::TEXT IS NOT NULL THEN pj.errors::TEXT END AS job_errors,
    pj.finalized_at AS job_finalized_at,
    pj.attempt AS job_attempt,
    tc.total
FROM paged_jobs pj
JOIN total_count tc ON TRUE
ORDER BY pj.id DESC
`

type ListJobsForWorkloadParams struct {
	Cluster       *string
	Namespace     *string
	WorkloadTypes []string
	WorkloadName  *string
	Offset        int32
	Limit         int32
}

type ListJobsForWorkloadRow struct {
	JobID          int64
	JobKind        string
	JobState       RiverJobState
	JobMetadata    interface{}
	JobErrors      interface{}
	JobFinalizedAt pgtype.Timestamptz
	JobAttempt     int16
	Total          int64
}

func (q *Queries) ListJobsForWorkload(ctx context.Context, arg ListJobsForWorkloadParams) ([]*ListJobsForWorkloadRow, error) {
	rows, err := q.db.Query(ctx, listJobsForWorkload,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadTypes,
		arg.WorkloadName,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListJobsForWorkloadRow{}
	for rows.Next() {
		var i ListJobsForWorkloadRow
		if err := rows.Scan(
			&i.JobID,
			&i.JobKind,
			&i.JobState,
			&i.JobMetadata,
			&i.JobErrors,
			&i.JobFinalizedAt,
			&i.JobAttempt,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRiverJobs = `-- name: ListRiverJobs :many
SELECT id, state, attempt, max_attempts, attempted_at, created_at, finalized_at, scheduled_at, priority, args, attempted_by, errors, kind, metadata, queue, tags, unique_key, unique_states
FROM river_job
WHERE
    (kind = 'add_workload' AND
    args->'Workload'->> 'Name' = $1::TEXT AND
    args->'Workload'->> 'WorkloadType' = $2::TEXT AND
    args->'Workload'->> 'Namespace' = $3::TEXT AND
    args->'Workload'->> 'Cluster' = $4::TEXT)
    OR
    (kind = 'get_attestation' AND
     args->> 'ImageName' = $5::TEXT AND
     args->> 'ImageTag' = $6::TEXT)
    OR
    (kind = 'upload_attestation' AND
     args->> 'ImageName' = $5::TEXT AND
     args->> 'ImageTag' = $6::TEXT)
    ORDER BY id
`

type ListRiverJobsParams struct {
	WorkloadName *string
	WorkloadType *string
	Namespace    *string
	Cluster      *string
	ImageName    *string
	ImageTag     *string
}

func (q *Queries) ListRiverJobs(ctx context.Context, arg ListRiverJobsParams) ([]*RiverJob, error) {
	rows, err := q.db.Query(ctx, listRiverJobs,
		arg.WorkloadName,
		arg.WorkloadType,
		arg.Namespace,
		arg.Cluster,
		arg.ImageName,
		arg.ImageTag,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*RiverJob{}
	for rows.Next() {
		var i RiverJob
		if err := rows.Scan(
			&i.ID,
			&i.State,
			&i.Attempt,
			&i.MaxAttempts,
			&i.AttemptedAt,
			&i.CreatedAt,
			&i.FinalizedAt,
			&i.ScheduledAt,
			&i.Priority,
			&i.Args,
			&i.AttemptedBy,
			&i.Errors,
			&i.Kind,
			&i.Metadata,
			&i.Queue,
			&i.Tags,
			&i.UniqueKey,
			&i.UniqueStates,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkloadStatus = `-- name: ListWorkloadStatus :many
WITH filtered_workloads AS (
    SELECT id, name, workload_type, namespace, cluster, image_name, image_tag, created_at, updated_at, state
    FROM workloads
    WHERE
        ($1::TEXT IS NULL OR cluster = $1::TEXT)
      AND ($2::TEXT IS NULL OR namespace = $2::TEXT)
      AND ($3::TEXT[] IS NULL OR workload_type = ANY($3::TEXT[]))
      AND ($4::TEXT IS NULL OR name = $4::TEXT)
),
     total_count AS (
         SELECT COUNT(*) AS total FROM filtered_workloads
     ),
     paged_workloads AS (
         SELECT id, name, workload_type, namespace, cluster, image_name, image_tag, created_at, updated_at, state FROM filtered_workloads
         ORDER BY id
    LIMIT $6 OFFSET $5
    )
SELECT
    w.name AS workload_name,
    w.workload_type,
    w.namespace,
    w.cluster,
    w.state AS workload_state,
    w.updated_at AS workload_updated_at,
    i.name AS image_name,
    i.tag AS image_tag,
    i.state AS image_state,
    i.updated_at AS image_updated_at,
    tc.total
FROM paged_workloads w
         JOIN total_count tc ON TRUE
         JOIN images i ON w.image_name = i.name AND w.image_tag = i.tag
ORDER BY w.id
`

type ListWorkloadStatusParams struct {
	Cluster       *string
	Namespace     *string
	WorkloadTypes []string
	WorkloadName  *string
	Offset        int32
	Limit         int32
}

type ListWorkloadStatusRow struct {
	WorkloadName      string
	WorkloadType      string
	Namespace         string
	Cluster           string
	WorkloadState     WorkloadState
	WorkloadUpdatedAt pgtype.Timestamptz
	ImageName         string
	ImageTag          string
	ImageState        ImageState
	ImageUpdatedAt    pgtype.Timestamptz
	Total             int64
}

func (q *Queries) ListWorkloadStatus(ctx context.Context, arg ListWorkloadStatusParams) ([]*ListWorkloadStatusRow, error) {
	rows, err := q.db.Query(ctx, listWorkloadStatus,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadTypes,
		arg.WorkloadName,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListWorkloadStatusRow{}
	for rows.Next() {
		var i ListWorkloadStatusRow
		if err := rows.Scan(
			&i.WorkloadName,
			&i.WorkloadType,
			&i.Namespace,
			&i.Cluster,
			&i.WorkloadState,
			&i.WorkloadUpdatedAt,
			&i.ImageName,
			&i.ImageTag,
			&i.ImageState,
			&i.ImageUpdatedAt,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkloadStatusWithJobs = `-- name: ListWorkloadStatusWithJobs :many
WITH filtered_workloads AS (
    SELECT id, name, workload_type, namespace, cluster, image_name, image_tag, created_at, updated_at, state
    FROM workloads
    WHERE
        ($1::TEXT IS NULL OR cluster = $1::TEXT)
      AND ($2::TEXT IS NULL OR namespace = $2::TEXT)
      AND ($3::TEXT[] IS NULL OR workload_type = ANY($3::TEXT[]))
      AND ($4::TEXT IS NULL OR name = $4::TEXT)
),
     total_count AS (
         SELECT COUNT(*) AS total FROM filtered_workloads
     ),
     paged_workloads AS (
         SELECT id, name, workload_type, namespace, cluster, image_name, image_tag, created_at, updated_at, state FROM filtered_workloads
         ORDER BY id
    LIMIT $6 OFFSET $5
    )
SELECT
    w.name AS workload_name,
    w.workload_type,
    w.namespace,
    w.cluster,
    w.state AS workload_state,
    w.updated_at AS workload_updated_at,
    i.name AS image_name,
    i.tag AS image_tag,
    i.state AS image_state,
    i.updated_at AS image_updated_at,
    rj.id AS job_id,
    rj.kind AS job_kind,
    rj.state AS job_state,
    CASE WHEN rj.metadata::TEXT IS NOT NULL THEN rj.metadata::TEXT END AS job_metadata,
    CASE WHEN rj.errors::TEXT IS NOT NULL THEN rj.metadata::TEXT END AS job_errors,
    rj.finalized_at AS job_finalized_at,
    rj.attempt AS job_attempt,
    tc.total
FROM paged_workloads w
JOIN total_count tc ON TRUE
JOIN images i ON w.image_name = i.name AND w.image_tag = i.tag
LEFT JOIN river_job rj ON (
    (rj.kind = 'add_workload' AND
     rj.args #>> '{Workload,Name}' = w.name AND
     rj.args #>> '{Workload,WorkloadType}' = w.workload_type AND
     rj.args #>> '{Workload,Namespace}' = w.namespace AND
     rj.args #>> '{Workload,Cluster}' = w.cluster)
 OR
    (rj.kind IN ('get_attestation', 'upload_attestation') AND
     rj.args #>> '{ImageName}' = w.image_name AND
     rj.args #>> '{ImageTag}' = w.image_tag)
)
ORDER BY w.id
`

type ListWorkloadStatusWithJobsParams struct {
	Cluster       *string
	Namespace     *string
	WorkloadTypes []string
	WorkloadName  *string
	Offset        int32
	Limit         int32
}

type ListWorkloadStatusWithJobsRow struct {
	WorkloadName      string
	WorkloadType      string
	Namespace         string
	Cluster           string
	WorkloadState     WorkloadState
	WorkloadUpdatedAt pgtype.Timestamptz
	ImageName         string
	ImageTag          string
	ImageState        ImageState
	ImageUpdatedAt    pgtype.Timestamptz
	JobID             *int64
	JobKind           *string
	JobState          NullRiverJobState
	JobMetadata       interface{}
	JobErrors         interface{}
	JobFinalizedAt    pgtype.Timestamptz
	JobAttempt        *int16
	Total             int64
}

func (q *Queries) ListWorkloadStatusWithJobs(ctx context.Context, arg ListWorkloadStatusWithJobsParams) ([]*ListWorkloadStatusWithJobsRow, error) {
	rows, err := q.db.Query(ctx, listWorkloadStatusWithJobs,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadTypes,
		arg.WorkloadName,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListWorkloadStatusWithJobsRow{}
	for rows.Next() {
		var i ListWorkloadStatusWithJobsRow
		if err := rows.Scan(
			&i.WorkloadName,
			&i.WorkloadType,
			&i.Namespace,
			&i.Cluster,
			&i.WorkloadState,
			&i.WorkloadUpdatedAt,
			&i.ImageName,
			&i.ImageTag,
			&i.ImageState,
			&i.ImageUpdatedAt,
			&i.JobID,
			&i.JobKind,
			&i.JobState,
			&i.JobMetadata,
			&i.JobErrors,
			&i.JobFinalizedAt,
			&i.JobAttempt,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
