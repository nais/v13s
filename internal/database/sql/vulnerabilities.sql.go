// Code generated by sqlc. DO NOT EDIT.
// source: vulnerabilities.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	typeext "github.com/nais/v13s/internal/database/typeext"
)

const countSuppressedVulnerabilities = `-- name: CountSuppressedVulnerabilities :one
SELECT COUNT(*) AS total
FROM suppressed_vulnerabilities sv
         JOIN vulnerabilities v
              ON sv.image_name = v.image_name
                  AND sv.package = v.package
                  AND sv.cve_id = v.cve_id
         JOIN cve c ON v.cve_id = c.cve_id
         JOIN workloads w ON v.image_name = w.image_name AND v.image_tag = w.image_tag
WHERE (CASE WHEN $1::TEXT is not null THEN w.cluster = $1::TEXT ELSE TRUE END)
  AND (CASE WHEN $2::TEXT is not null THEN w.namespace = $2::TEXT ELSE TRUE END)
  AND (CASE WHEN $3::TEXT is not null THEN w.workload_type = $3::TEXT ELSE TRUE END)
  AND (CASE WHEN $4::TEXT is not null THEN w.name = $4::TEXT ELSE TRUE END)
  AND (CASE WHEN $5::TEXT is not null THEN v.image_name = $5::TEXT ELSE TRUE END)
  AND (CASE WHEN $6::TEXT is not null THEN v.image_tag = $6::TEXT ELSE TRUE END)
`

type CountSuppressedVulnerabilitiesParams struct {
	Cluster      *string
	Namespace    *string
	WorkloadType *string
	WorkloadName *string
	ImageName    *string
	ImageTag     *string
}

func (q *Queries) CountSuppressedVulnerabilities(ctx context.Context, arg CountSuppressedVulnerabilitiesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSuppressedVulnerabilities,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadType,
		arg.WorkloadName,
		arg.ImageName,
		arg.ImageTag,
	)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countVulnerabilities = `-- name: CountVulnerabilities :one
SELECT COUNT(*) AS total
FROM vulnerabilities v
         JOIN cve c ON v.cve_id = c.cve_id
         JOIN workloads w ON v.image_name = w.image_name AND v.image_tag = w.image_tag
         LEFT JOIN suppressed_vulnerabilities sv
                   ON v.image_name = sv.image_name
                       AND v.package = sv.package
                       AND v.cve_id = sv.cve_id
WHERE (CASE WHEN $1::TEXT is not null THEN w.cluster = $1::TEXT ELSE TRUE END)
  AND (CASE WHEN $2::TEXT is not null THEN w.namespace = $2::TEXT ELSE TRUE END)
  AND (CASE
           WHEN $3::TEXT is not null THEN w.workload_type = $3::TEXT
           ELSE TRUE END)
  AND (CASE
           WHEN $4::TEXT is not null THEN w.name = $4::TEXT
           ELSE TRUE END)
  AND ($5::BOOLEAN IS TRUE OR COALESCE(sv.suppressed, FALSE) = FALSE)
`

type CountVulnerabilitiesParams struct {
	Cluster           *string
	Namespace         *string
	WorkloadType      *string
	WorkloadName      *string
	IncludeSuppressed *bool
}

func (q *Queries) CountVulnerabilities(ctx context.Context, arg CountVulnerabilitiesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countVulnerabilities,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadType,
		arg.WorkloadName,
		arg.IncludeSuppressed,
	)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const generateVulnerabilitySummaryForImage = `-- name: GenerateVulnerabilitySummaryForImage :one
SELECT COUNT(*) AS total,
       SUM(CASE WHEN c.severity = 5 THEN 1 ELSE 0 END) AS critical,
       SUM(CASE WHEN c.severity = 4 THEN 1 ELSE 0 END) AS high,
       SUM(CASE WHEN c.severity = 3 THEN 1 ELSE 0 END) AS medium,
       SUM(CASE WHEN c.severity = 2 THEN 1 ELSE 0 END) AS low,
       SUM(CASE WHEN c.severity = 1 THEN 1 ELSE 0 END) AS unassigned,
       -- 10*critical + 5*high + 3*medium + 1*low + 5*unassigned
         10 * SUM(CASE WHEN c.severity = 5 THEN 1 ELSE 0 END) +
            5 * SUM(CASE WHEN c.severity = 4 THEN 1 ELSE 0 END) +
            3 * SUM(CASE WHEN c.severity = 3 THEN 1 ELSE 0 END) +
            1 * SUM(CASE WHEN c.severity = 2 THEN 1 ELSE 0 END) +
            5 * SUM(CASE WHEN c.severity = 1 THEN 1 ELSE 0 END) AS risk_score

FROM vulnerabilities v
         JOIN cve c ON v.cve_id = c.cve_id
WHERE v.image_name = $1
    AND v.image_tag = $2
`

type GenerateVulnerabilitySummaryForImageParams struct {
	ImageName string
	ImageTag  string
}

type GenerateVulnerabilitySummaryForImageRow struct {
	Total      int64
	Critical   int64
	High       int64
	Medium     int64
	Low        int64
	Unassigned int64
	RiskScore  int32
}

func (q *Queries) GenerateVulnerabilitySummaryForImage(ctx context.Context, arg GenerateVulnerabilitySummaryForImageParams) (*GenerateVulnerabilitySummaryForImageRow, error) {
	row := q.db.QueryRow(ctx, generateVulnerabilitySummaryForImage, arg.ImageName, arg.ImageTag)
	var i GenerateVulnerabilitySummaryForImageRow
	err := row.Scan(
		&i.Total,
		&i.Critical,
		&i.High,
		&i.Medium,
		&i.Low,
		&i.Unassigned,
		&i.RiskScore,
	)
	return &i, err
}

const getCve = `-- name: GetCve :one
SELECT cve_id, cve_title, cve_desc, cve_link, severity, refs, created_at, updated_at, cvss_score
FROM cve
WHERE cve_id = $1
`

func (q *Queries) GetCve(ctx context.Context, cveID string) (*Cve, error) {
	row := q.db.QueryRow(ctx, getCve, cveID)
	var i Cve
	err := row.Scan(
		&i.CveID,
		&i.CveTitle,
		&i.CveDesc,
		&i.CveLink,
		&i.Severity,
		&i.Refs,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CvssScore,
	)
	return &i, err
}

const getEarliestSeveritySinceForVulnerability = `-- name: GetEarliestSeveritySinceForVulnerability :one
SELECT (COALESCE(
        (SELECT MIN(v1.severity_since)
         FROM vulnerabilities v1
         WHERE v1.image_name = $1
           AND v1.package = $2
           AND v1.cve_id = $3
           AND v1.last_severity = $4
           AND v1.severity_since IS NOT NULL),
        (SELECT MIN(v2.created_at)
         FROM vulnerabilities v2
         WHERE v2.image_name = $1
           AND v2.package = $2
           AND v2.cve_id = $3
         AND v2.last_severity = $4)
        )::timestamptz) AS earliest_severity_since
`

type GetEarliestSeveritySinceForVulnerabilityParams struct {
	ImageName    string
	Package      string
	CveID        string
	LastSeverity int32
}

func (q *Queries) GetEarliestSeveritySinceForVulnerability(ctx context.Context, arg GetEarliestSeveritySinceForVulnerabilityParams) (pgtype.Timestamptz, error) {
	row := q.db.QueryRow(ctx, getEarliestSeveritySinceForVulnerability,
		arg.ImageName,
		arg.Package,
		arg.CveID,
		arg.LastSeverity,
	)
	var earliest_severity_since pgtype.Timestamptz
	err := row.Scan(&earliest_severity_since)
	return earliest_severity_since, err
}

const getVulnerability = `-- name: GetVulnerability :one
SELECT v.id,
       v.image_name,
       v.image_tag,
       v.package,
       v.latest_version,
       v.source,
       v.cve_id,
       v.last_severity,
       v.severity_since,
       v.created_at,
       v.updated_at,
       c.cve_title,
       c.cve_desc,
       c.cve_link,
       c.severity AS severity,
       c.refs,
       COALESCE(sv.suppressed, FALSE) AS suppressed,
       sv.reason,
       sv.reason_text,
       sv.suppressed_by,
       sv.updated_at AS suppressed_at
FROM vulnerabilities v
         JOIN cve c ON v.cve_id = c.cve_id
         LEFT JOIN suppressed_vulnerabilities sv
                   ON v.image_name = sv.image_name
                       AND v.package = sv.package
                       AND v.cve_id = sv.cve_id
WHERE v.image_name = $1
  AND v.image_tag = $2
  AND v.package = $3
  AND v.cve_id = $4
`

type GetVulnerabilityParams struct {
	ImageName string
	ImageTag  string
	Package   string
	CveID     string
}

type GetVulnerabilityRow struct {
	ID            pgtype.UUID
	ImageName     string
	ImageTag      string
	Package       string
	LatestVersion string
	Source        string
	CveID         string
	LastSeverity  int32
	SeveritySince pgtype.Timestamptz
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	CveTitle      string
	CveDesc       string
	CveLink       string
	Severity      int32
	Refs          typeext.MapStringString
	Suppressed    bool
	Reason        NullVulnerabilitySuppressReason
	ReasonText    *string
	SuppressedBy  *string
	SuppressedAt  pgtype.Timestamptz
}

func (q *Queries) GetVulnerability(ctx context.Context, arg GetVulnerabilityParams) (*GetVulnerabilityRow, error) {
	row := q.db.QueryRow(ctx, getVulnerability,
		arg.ImageName,
		arg.ImageTag,
		arg.Package,
		arg.CveID,
	)
	var i GetVulnerabilityRow
	err := row.Scan(
		&i.ID,
		&i.ImageName,
		&i.ImageTag,
		&i.Package,
		&i.LatestVersion,
		&i.Source,
		&i.CveID,
		&i.LastSeverity,
		&i.SeveritySince,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CveTitle,
		&i.CveDesc,
		&i.CveLink,
		&i.Severity,
		&i.Refs,
		&i.Suppressed,
		&i.Reason,
		&i.ReasonText,
		&i.SuppressedBy,
		&i.SuppressedAt,
	)
	return &i, err
}

const getVulnerabilityById = `-- name: GetVulnerabilityById :one
SELECT v.id,
       v.image_name,
       v.image_tag,
       v.package,
       v.latest_version,
       v.source,
       v.cve_id,
       v.created_at,
       v.updated_at,
       c.cve_title,
       c.cve_desc,
       c.cve_link,
       c.severity AS severity,
       COALESCE(sv.suppressed, FALSE) AS suppressed,
       c.refs,
       sv.reason,
       sv.reason_text,
       sv.suppressed_by,
       sv.updated_at as suppressed_at
FROM vulnerabilities v
    JOIN cve c ON v.cve_id = c.cve_id
    LEFT JOIN suppressed_vulnerabilities sv
              ON v.image_name = sv.image_name
                  AND v.package = sv.package
                  AND v.cve_id = sv.cve_id
WHERE v.id = $1
`

type GetVulnerabilityByIdRow struct {
	ID            pgtype.UUID
	ImageName     string
	ImageTag      string
	Package       string
	LatestVersion string
	Source        string
	CveID         string
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	CveTitle      string
	CveDesc       string
	CveLink       string
	Severity      int32
	Suppressed    bool
	Refs          typeext.MapStringString
	Reason        NullVulnerabilitySuppressReason
	ReasonText    *string
	SuppressedBy  *string
	SuppressedAt  pgtype.Timestamptz
}

func (q *Queries) GetVulnerabilityById(ctx context.Context, id pgtype.UUID) (*GetVulnerabilityByIdRow, error) {
	row := q.db.QueryRow(ctx, getVulnerabilityById, id)
	var i GetVulnerabilityByIdRow
	err := row.Scan(
		&i.ID,
		&i.ImageName,
		&i.ImageTag,
		&i.Package,
		&i.LatestVersion,
		&i.Source,
		&i.CveID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CveTitle,
		&i.CveDesc,
		&i.CveLink,
		&i.Severity,
		&i.Suppressed,
		&i.Refs,
		&i.Reason,
		&i.ReasonText,
		&i.SuppressedBy,
		&i.SuppressedAt,
	)
	return &i, err
}

const listSeverityVulnerabilitiesSince = `-- name: ListSeverityVulnerabilitiesSince :many
SELECT
    v.id,
    w.name AS workload_name,
    w.workload_type,
    w.namespace,
    w.cluster,
    v.image_name,
    v.image_tag,
    v.latest_version,
    v.package,
    v.cve_id,
    v.created_at,
    v.updated_at,
    v.severity_since,
    v.last_severity,
    c.cve_title,
    c.cve_desc,
    c.cve_link,
    c.severity AS severity,
    c.created_at AS cve_created_at,
    c.updated_at AS cve_updated_at,
    COALESCE(sv.suppressed, FALSE) AS suppressed,
    sv.reason,
    sv.reason_text,
    sv.suppressed_by,
    sv.updated_at AS suppressed_at,
    v.cvss_score
FROM vulnerabilities v
         JOIN cve c ON v.cve_id = c.cve_id
         JOIN workloads w ON v.image_name = w.image_name AND v.image_tag = w.image_tag
         LEFT JOIN suppressed_vulnerabilities sv
                   ON v.image_name = sv.image_name
                       AND v.package = sv.package
                       AND v.cve_id = sv.cve_id
WHERE v.severity_since IS NOT NULL
  AND (CASE WHEN $1::TEXT IS NOT NULL THEN w.cluster = $1::TEXT ELSE TRUE END)
  AND (CASE WHEN $2::TEXT IS NOT NULL THEN w.namespace = $2::TEXT ELSE TRUE END)
  AND (CASE WHEN $3::TEXT IS NOT NULL THEN w.workload_type = $3::TEXT ELSE TRUE END)
  AND (CASE WHEN $4::TEXT IS NOT NULL THEN w.name = $4::TEXT ELSE TRUE END)
  AND (CASE WHEN $5::TEXT IS NOT NULL THEN v.image_name = $5::TEXT ELSE TRUE END)
  AND (CASE WHEN $6::TEXT IS NOT NULL THEN v.image_tag = $6::TEXT ELSE TRUE END)
  AND ($7::BOOLEAN IS TRUE OR COALESCE(sv.suppressed, FALSE) = FALSE)
  AND ($8::timestamptz IS NULL OR v.severity_since > $8::timestamptz)
ORDER BY
         CASE WHEN $9 = 'severity_since_desc' THEN v.severity_since END DESC,
         CASE WHEN $9 = 'severity_since_asc' THEN v.severity_since END ASC,
         CASE WHEN $9 = 'workload_asc' THEN w.name END ASC,
         CASE WHEN $9 = 'workload_desc' THEN w.name END DESC,
         CASE WHEN $9 = 'namespace_asc' THEN w.namespace END ASC,
         CASE WHEN $9 = 'namespace_desc' THEN w.namespace END DESC,
         CASE WHEN $9 = 'cluster_asc' THEN w.cluster END ASC,
         CASE WHEN $9 = 'cluster_desc' THEN w.cluster END DESC,
         v.id ASC LIMIT $11
OFFSET $10
`

type ListSeverityVulnerabilitiesSinceParams struct {
	Cluster           *string
	Namespace         *string
	WorkloadType      *string
	WorkloadName      *string
	ImageName         *string
	ImageTag          *string
	IncludeSuppressed *bool
	Since             pgtype.Timestamptz
	OrderBy           interface{}
	Offset            int32
	Limit             int32
}

type ListSeverityVulnerabilitiesSinceRow struct {
	ID            pgtype.UUID
	WorkloadName  string
	WorkloadType  string
	Namespace     string
	Cluster       string
	ImageName     string
	ImageTag      string
	LatestVersion string
	Package       string
	CveID         string
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	SeveritySince pgtype.Timestamptz
	LastSeverity  int32
	CveTitle      string
	CveDesc       string
	CveLink       string
	Severity      int32
	CveCreatedAt  pgtype.Timestamptz
	CveUpdatedAt  pgtype.Timestamptz
	Suppressed    bool
	Reason        NullVulnerabilitySuppressReason
	ReasonText    *string
	SuppressedBy  *string
	SuppressedAt  pgtype.Timestamptz
	CvssScore     *float64
}

func (q *Queries) ListSeverityVulnerabilitiesSince(ctx context.Context, arg ListSeverityVulnerabilitiesSinceParams) ([]*ListSeverityVulnerabilitiesSinceRow, error) {
	rows, err := q.db.Query(ctx, listSeverityVulnerabilitiesSince,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadType,
		arg.WorkloadName,
		arg.ImageName,
		arg.ImageTag,
		arg.IncludeSuppressed,
		arg.Since,
		arg.OrderBy,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListSeverityVulnerabilitiesSinceRow{}
	for rows.Next() {
		var i ListSeverityVulnerabilitiesSinceRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkloadName,
			&i.WorkloadType,
			&i.Namespace,
			&i.Cluster,
			&i.ImageName,
			&i.ImageTag,
			&i.LatestVersion,
			&i.Package,
			&i.CveID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SeveritySince,
			&i.LastSeverity,
			&i.CveTitle,
			&i.CveDesc,
			&i.CveLink,
			&i.Severity,
			&i.CveCreatedAt,
			&i.CveUpdatedAt,
			&i.Suppressed,
			&i.Reason,
			&i.ReasonText,
			&i.SuppressedBy,
			&i.SuppressedAt,
			&i.CvssScore,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSuppressedVulnerabilities = `-- name: ListSuppressedVulnerabilities :many
SELECT sv.id, sv.image_name, sv.package, sv.cve_id, sv.suppressed, sv.reason, sv.reason_text, sv.created_at, sv.updated_at, sv.suppressed_by, v.id, v.image_name, v.image_tag, v.package, v.cve_id, v.source, v.latest_version, v.created_at, v.updated_at, v.last_severity, v.severity_since, v.cvss_score, c.cve_id, c.cve_title, c.cve_desc, c.cve_link, c.severity, c.refs, c.created_at, c.updated_at, c.cvss_score, w.cluster, w.namespace
FROM suppressed_vulnerabilities sv
         JOIN vulnerabilities v
              ON sv.image_name = v.image_name
                  AND sv.package = v.package
                  AND sv.cve_id = v.cve_id
         JOIN cve c ON v.cve_id = c.cve_id
         JOIN workloads w ON v.image_name = w.image_name
    AND v.image_tag = w.image_tag
WHERE (CASE WHEN $1::TEXT IS NOT NULL THEN w.cluster = $1::TEXT ELSE TRUE END)
  AND (CASE WHEN $2::TEXT IS NOT NULL THEN w.namespace = $2::TEXT ELSE TRUE END)
  AND (CASE WHEN $3::TEXT IS NOT NULL THEN v.image_name = $3::TEXT ELSE TRUE END)
  AND (CASE WHEN $4::TEXT IS NOT NULL THEN v.image_tag = $4::TEXT ELSE TRUE END)
ORDER BY
    CASE WHEN $5 = 'severity_asc' THEN c.severity END ASC,
    CASE WHEN $5 = 'severity_desc' THEN c.severity END DESC,
    CASE WHEN $5 = 'workload_asc' THEN w.name END ASC,
    CASE WHEN $5 = 'workload_desc' THEN w.name END DESC,
    CASE WHEN $5 = 'namespace_asc' THEN w.namespace END ASC,
    CASE WHEN $5 = 'namespace_desc' THEN w.namespace END DESC,
    CASE WHEN $5 = 'cluster_asc' THEN w.cluster END ASC,
    CASE WHEN $5 = 'cluster_desc' THEN w.cluster END DESC,
    v.id ASC
    LIMIT $7 OFFSET $6
`

type ListSuppressedVulnerabilitiesParams struct {
	Cluster   *string
	Namespace *string
	ImageName *string
	ImageTag  *string
	OrderBy   interface{}
	Offset    int32
	Limit     int32
}

type ListSuppressedVulnerabilitiesRow struct {
	ID            pgtype.UUID
	ImageName     string
	Package       string
	CveID         string
	Suppressed    bool
	Reason        VulnerabilitySuppressReason
	ReasonText    string
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	SuppressedBy  string
	ID_2          pgtype.UUID
	ImageName_2   string
	ImageTag      string
	Package_2     string
	CveID_2       string
	Source        string
	LatestVersion string
	CreatedAt_2   pgtype.Timestamptz
	UpdatedAt_2   pgtype.Timestamptz
	LastSeverity  int32
	SeveritySince pgtype.Timestamptz
	CvssScore     *float64
	CveID_3       string
	CveTitle      string
	CveDesc       string
	CveLink       string
	Severity      int32
	Refs          typeext.MapStringString
	CreatedAt_3   pgtype.Timestamptz
	UpdatedAt_3   pgtype.Timestamptz
	CvssScore_2   *float64
	Cluster       string
	Namespace     string
}

func (q *Queries) ListSuppressedVulnerabilities(ctx context.Context, arg ListSuppressedVulnerabilitiesParams) ([]*ListSuppressedVulnerabilitiesRow, error) {
	rows, err := q.db.Query(ctx, listSuppressedVulnerabilities,
		arg.Cluster,
		arg.Namespace,
		arg.ImageName,
		arg.ImageTag,
		arg.OrderBy,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListSuppressedVulnerabilitiesRow{}
	for rows.Next() {
		var i ListSuppressedVulnerabilitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.ImageName,
			&i.Package,
			&i.CveID,
			&i.Suppressed,
			&i.Reason,
			&i.ReasonText,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SuppressedBy,
			&i.ID_2,
			&i.ImageName_2,
			&i.ImageTag,
			&i.Package_2,
			&i.CveID_2,
			&i.Source,
			&i.LatestVersion,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.LastSeverity,
			&i.SeveritySince,
			&i.CvssScore,
			&i.CveID_3,
			&i.CveTitle,
			&i.CveDesc,
			&i.CveLink,
			&i.Severity,
			&i.Refs,
			&i.CreatedAt_3,
			&i.UpdatedAt_3,
			&i.CvssScore_2,
			&i.Cluster,
			&i.Namespace,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSuppressedVulnerabilitiesForImage = `-- name: ListSuppressedVulnerabilitiesForImage :many
SELECT id, image_name, package, cve_id, suppressed, reason, reason_text, created_at, updated_at, suppressed_by
FROM suppressed_vulnerabilities
WHERE image_name = $1
ORDER BY updated_at DESC
`

func (q *Queries) ListSuppressedVulnerabilitiesForImage(ctx context.Context, imageName string) ([]*SuppressedVulnerability, error) {
	rows, err := q.db.Query(ctx, listSuppressedVulnerabilitiesForImage, imageName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SuppressedVulnerability{}
	for rows.Next() {
		var i SuppressedVulnerability
		if err := rows.Scan(
			&i.ID,
			&i.ImageName,
			&i.Package,
			&i.CveID,
			&i.Suppressed,
			&i.Reason,
			&i.ReasonText,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SuppressedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVulnerabilities = `-- name: ListVulnerabilities :many
SELECT v.id,
       w.name                         AS workload_name,
       w.workload_type,
       w.namespace,
       w.cluster,
       v.image_name,
       v.image_tag,
       v.latest_version,
       v.severity_since,
       v.package,
       v.cve_id,
       v.created_at,
       v.updated_at,
       c.cve_title,
       c.cve_desc,
       c.cve_link,
       c.severity AS severity,
       c.created_at AS cve_created_at,
       c.updated_at AS cve_updated_at,
       COALESCE(sv.suppressed, FALSE) AS suppressed,
       sv.reason,
       sv.reason_text,
       sv.suppressed_by,
       sv.updated_at as suppressed_at,
       v.cvss_score
FROM vulnerabilities v
         JOIN cve c ON v.cve_id = c.cve_id
         JOIN workloads w ON v.image_name = w.image_name AND v.image_tag = w.image_tag
         LEFT JOIN suppressed_vulnerabilities sv
                   ON v.image_name = sv.image_name
                       AND v.package = sv.package
                       AND v.cve_id = sv.cve_id
WHERE (CASE WHEN $1::TEXT is not null THEN w.cluster = $1::TEXT ELSE TRUE END)
  AND (CASE WHEN $2::TEXT is not null THEN w.namespace = $2::TEXT ELSE TRUE END)
  AND (CASE
           WHEN $3::TEXT is not null THEN w.workload_type = $3::TEXT
           ELSE TRUE END)
  AND (CASE
           WHEN $4::TEXT is not null THEN w.name = $4::TEXT
           ELSE TRUE END)
  AND (CASE
           WHEN $5::TEXT is not null THEN v.image_name = $5::TEXT
           ELSE TRUE END)
  AND (CASE WHEN $6::TEXT is not null THEN v.image_tag = $6::TEXT ELSE TRUE END)
  AND ($7::BOOLEAN IS TRUE OR COALESCE(sv.suppressed, FALSE) = FALSE)
ORDER BY
    CASE WHEN $8 = 'severity_asc' THEN c.severity END ASC,
    CASE WHEN $8 = 'severity_desc' THEN c.severity END DESC,
    CASE WHEN $8 = 'workload_asc' THEN w.name END ASC,
    CASE WHEN $8 = 'workload_desc' THEN w.name END DESC,
    CASE WHEN $8 = 'namespace_asc' THEN w.namespace END ASC,
    CASE WHEN $8 = 'namespace_desc' THEN w.namespace END DESC,
    CASE WHEN $8 = 'cluster_asc' THEN w.cluster END ASC,
    CASE WHEN $8 = 'cluster_desc' THEN w.cluster END DESC,
    CASE WHEN $8 = 'created_at_asc' THEN v.created_at END ASC,
    CASE WHEN $8 = 'created_at_desc' THEN v.created_at END DESC,
    CASE WHEN $8 = 'updated_at_asc' THEN v.updated_at END ASC,
    CASE WHEN $8 = 'updated_at_desc' THEN v.updated_at END DESC,
    v.id ASC
LIMIT $10 OFFSET $9
`

type ListVulnerabilitiesParams struct {
	Cluster           *string
	Namespace         *string
	WorkloadType      *string
	WorkloadName      *string
	ImageName         *string
	ImageTag          *string
	IncludeSuppressed *bool
	OrderBy           interface{}
	Offset            int32
	Limit             int32
}

type ListVulnerabilitiesRow struct {
	ID            pgtype.UUID
	WorkloadName  string
	WorkloadType  string
	Namespace     string
	Cluster       string
	ImageName     string
	ImageTag      string
	LatestVersion string
	SeveritySince pgtype.Timestamptz
	Package       string
	CveID         string
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	CveTitle      string
	CveDesc       string
	CveLink       string
	Severity      int32
	CveCreatedAt  pgtype.Timestamptz
	CveUpdatedAt  pgtype.Timestamptz
	Suppressed    bool
	Reason        NullVulnerabilitySuppressReason
	ReasonText    *string
	SuppressedBy  *string
	SuppressedAt  pgtype.Timestamptz
	CvssScore     *float64
}

func (q *Queries) ListVulnerabilities(ctx context.Context, arg ListVulnerabilitiesParams) ([]*ListVulnerabilitiesRow, error) {
	rows, err := q.db.Query(ctx, listVulnerabilities,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadType,
		arg.WorkloadName,
		arg.ImageName,
		arg.ImageTag,
		arg.IncludeSuppressed,
		arg.OrderBy,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListVulnerabilitiesRow{}
	for rows.Next() {
		var i ListVulnerabilitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkloadName,
			&i.WorkloadType,
			&i.Namespace,
			&i.Cluster,
			&i.ImageName,
			&i.ImageTag,
			&i.LatestVersion,
			&i.SeveritySince,
			&i.Package,
			&i.CveID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CveTitle,
			&i.CveDesc,
			&i.CveLink,
			&i.Severity,
			&i.CveCreatedAt,
			&i.CveUpdatedAt,
			&i.Suppressed,
			&i.Reason,
			&i.ReasonText,
			&i.SuppressedBy,
			&i.SuppressedAt,
			&i.CvssScore,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVulnerabilitiesForImage = `-- name: ListVulnerabilitiesForImage :many
WITH image_vulnerabilities AS (
    SELECT v.id,
          v.image_name,
          v.image_tag,
          v.package,
          v.cve_id,
          v.latest_version,
          v.created_at,
          v.updated_at,
          v.severity_since,
          c.cve_title,
          c.cve_desc,
          c.cve_link,
          c.severity,
          c.refs::JSONB AS cve_refs,
          c.created_at AS cve_created_at,
          c.updated_at AS cve_updated_at,
          COALESCE(sv.suppressed, FALSE) AS suppressed,
          sv.reason,
          sv.reason_text,
          sv.suppressed_by,
          sv.updated_at as suppressed_at,
          v.cvss_score
    FROM vulnerabilities v
            JOIN cve c ON v.cve_id = c.cve_id
            JOIN images i ON v.image_name = i.name AND v.image_tag = i.tag
            LEFT JOIN suppressed_vulnerabilities sv
                      ON v.image_name = sv.image_name
                          AND v.package = sv.package
                          AND v.cve_id = sv.cve_id
    WHERE v.image_name = $4
     AND v.image_tag = $5
     AND ($6::BOOLEAN IS TRUE OR COALESCE(sv.suppressed, FALSE) = FALSE)
     AND ($7::timestamptz IS NULL OR v.severity_since > $7::timestamptz)
     AND ($8::INT IS NULL OR c.severity = $8::INT)
)
SELECT id,
       image_name,
       image_tag,
       package,
       cve_id,
       latest_version,
       created_at,
       updated_at,
       severity_since,
       cve_title,
       cve_desc,
       cve_link,
       severity,
       cve_refs as cve_refs,
       cve_created_at,
       cve_updated_at,
       COALESCE(suppressed, FALSE) AS suppressed,
       reason,
       reason_text,
       suppressed_by,
       suppressed_at,
       (SELECT COUNT(*) FROM image_vulnerabilities) AS total_count,
        cvss_score
FROM image_vulnerabilities
ORDER BY CASE WHEN $1 = 'severity_asc' THEN severity END ASC,
         CASE WHEN $1 = 'severity_desc' THEN severity END DESC,
         CASE WHEN $1 = 'severity_since_asc' THEN severity_since END ASC,
         CASE WHEN $1 = 'severity_since_desc' THEN severity_since END DESC,
         CASE WHEN $1 = 'package_asc' THEN package END ASC,
         CASE WHEN $1 = 'package_desc' THEN package END DESC,
         CASE WHEN $1 = 'cve_id_asc' THEN cve_id END ASC,
         CASE WHEN $1 = 'cve_id_desc' THEN cve_id END DESC,
         CASE WHEN $1 = 'suppressed_asc' THEN COALESCE(suppressed, FALSE) END ASC,
         CASE WHEN $1 = 'suppressed_desc' THEN COALESCE(suppressed, FALSE) END DESC,
         CASE WHEN $1 = 'reason_asc' THEN reason END ASC,
         CASE WHEN $1 = 'reason_desc' THEN reason END DESC,
         CASE WHEN $1 = 'created_at_asc' THEN created_at END ASC,
         CASE WHEN $1 = 'created_at_desc' THEN created_at END DESC,
         CASE WHEN $1 = 'updated_at_asc' THEN updated_at END ASC,
         CASE WHEN $1 = 'updated_at_desc' THEN updated_at END DESC,
         severity, id ASC
    LIMIT $3
OFFSET $2
`

type ListVulnerabilitiesForImageParams struct {
	OrderBy           interface{}
	Offset            int32
	Limit             int32
	ImageName         string
	ImageTag          string
	IncludeSuppressed *bool
	Since             pgtype.Timestamptz
	Severity          *int32
}

type ListVulnerabilitiesForImageRow struct {
	ID            pgtype.UUID
	ImageName     string
	ImageTag      string
	Package       string
	CveID         string
	LatestVersion string
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	SeveritySince pgtype.Timestamptz
	CveTitle      string
	CveDesc       string
	CveLink       string
	Severity      int32
	CveRefs       []byte
	CveCreatedAt  pgtype.Timestamptz
	CveUpdatedAt  pgtype.Timestamptz
	Suppressed    bool
	Reason        NullVulnerabilitySuppressReason
	ReasonText    *string
	SuppressedBy  *string
	SuppressedAt  pgtype.Timestamptz
	TotalCount    int64
	CvssScore     *float64
}

func (q *Queries) ListVulnerabilitiesForImage(ctx context.Context, arg ListVulnerabilitiesForImageParams) ([]*ListVulnerabilitiesForImageRow, error) {
	rows, err := q.db.Query(ctx, listVulnerabilitiesForImage,
		arg.OrderBy,
		arg.Offset,
		arg.Limit,
		arg.ImageName,
		arg.ImageTag,
		arg.IncludeSuppressed,
		arg.Since,
		arg.Severity,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListVulnerabilitiesForImageRow{}
	for rows.Next() {
		var i ListVulnerabilitiesForImageRow
		if err := rows.Scan(
			&i.ID,
			&i.ImageName,
			&i.ImageTag,
			&i.Package,
			&i.CveID,
			&i.LatestVersion,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SeveritySince,
			&i.CveTitle,
			&i.CveDesc,
			&i.CveLink,
			&i.Severity,
			&i.CveRefs,
			&i.CveCreatedAt,
			&i.CveUpdatedAt,
			&i.Suppressed,
			&i.Reason,
			&i.ReasonText,
			&i.SuppressedBy,
			&i.SuppressedAt,
			&i.TotalCount,
			&i.CvssScore,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkloadsForVulnerabilities = `-- name: ListWorkloadsForVulnerabilities :many
SELECT
    v.id,
    w.name AS workload_name,
    w.workload_type,
    w.namespace,
    w.cluster,
    w.image_name,
    w.image_tag,
    v.latest_version,
    v.package,
    v.cve_id,
    v.created_at,
    v.updated_at,
    v.severity_since,
    v.last_severity,
    c.cve_title,
    c.cve_desc,
    c.cve_link,
    c.severity AS severity,
    c.created_at AS cve_created_at,
    c.updated_at AS cve_updated_at,
    COALESCE(sv.suppressed, FALSE) AS suppressed,
    sv.reason,
    sv.reason_text,
    sv.suppressed_by,
    sv.updated_at AS suppressed_at,
    v.cvss_score,
    COUNT(v.id) OVER() as total_count
FROM vulnerabilities v
    JOIN cve c ON v.cve_id = c.cve_id
    JOIN workloads w ON w.image_name = v.image_name AND w.image_tag = v.image_tag
    LEFT JOIN suppressed_vulnerabilities sv
              ON v.image_name = sv.image_name
                  AND v.package = sv.package
                  AND v.cve_id = sv.cve_id
WHERE
    ($1::TEXT[] IS NULL OR v.cve_id = ANY($1::TEXT[]))
    AND
    ($2::FLOAT8 IS NULL OR (v.cvss_score IS NOT NULL AND v.cvss_score >= $2::FLOAT8))
    AND (CASE WHEN $3::TEXT IS NOT NULL THEN w.cluster = $3::TEXT ELSE TRUE END)
    AND (CASE WHEN $4::TEXT IS NOT NULL THEN w.namespace = $4::TEXT ELSE TRUE END)
    AND (CASE WHEN $5::TEXT IS NOT NULL THEN w.workload_type = $5::TEXT ELSE TRUE END)
    AND (CASE WHEN $6::TEXT IS NOT NULL THEN w.name = $6::TEXT ELSE TRUE END)
    AND (CASE WHEN $7::TEXT IS NOT NULL THEN v.image_name = $7::TEXT ELSE TRUE END)
    AND (CASE WHEN $8::TEXT IS NOT NULL THEN v.image_tag = $8::TEXT ELSE TRUE END)
ORDER BY
    CASE WHEN $9 = 'cve_id_desc' THEN v.cve_id END DESC,
    CASE WHEN $9 = 'cve_id_asc' THEN v.cve_id END ASC,
    CASE WHEN $9 = 'workload_asc' THEN w.name END ASC,
    CASE WHEN $9 = 'workload_desc' THEN w.name END DESC,
    CASE WHEN $9 = 'namespace_asc' THEN w.namespace END ASC,
    CASE WHEN $9 = 'namespace_desc' THEN w.namespace END DESC,
    CASE WHEN $9 = 'cluster_asc' THEN w.cluster END ASC,
    CASE WHEN $9 = 'cluster_desc' THEN w.cluster END DESC,
    v.id ASC LIMIT $11
OFFSET $10
`

type ListWorkloadsForVulnerabilitiesParams struct {
	CveIds       []string
	CvssScore    *float64
	Cluster      *string
	Namespace    *string
	WorkloadType *string
	WorkloadName *string
	ImageName    *string
	ImageTag     *string
	OrderBy      interface{}
	Offset       int32
	Limit        int32
}

type ListWorkloadsForVulnerabilitiesRow struct {
	ID            pgtype.UUID
	WorkloadName  string
	WorkloadType  string
	Namespace     string
	Cluster       string
	ImageName     string
	ImageTag      string
	LatestVersion string
	Package       string
	CveID         string
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	SeveritySince pgtype.Timestamptz
	LastSeverity  int32
	CveTitle      string
	CveDesc       string
	CveLink       string
	Severity      int32
	CveCreatedAt  pgtype.Timestamptz
	CveUpdatedAt  pgtype.Timestamptz
	Suppressed    bool
	Reason        NullVulnerabilitySuppressReason
	ReasonText    *string
	SuppressedBy  *string
	SuppressedAt  pgtype.Timestamptz
	CvssScore     *float64
	TotalCount    int64
}

func (q *Queries) ListWorkloadsForVulnerabilities(ctx context.Context, arg ListWorkloadsForVulnerabilitiesParams) ([]*ListWorkloadsForVulnerabilitiesRow, error) {
	rows, err := q.db.Query(ctx, listWorkloadsForVulnerabilities,
		arg.CveIds,
		arg.CvssScore,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadType,
		arg.WorkloadName,
		arg.ImageName,
		arg.ImageTag,
		arg.OrderBy,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListWorkloadsForVulnerabilitiesRow{}
	for rows.Next() {
		var i ListWorkloadsForVulnerabilitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkloadName,
			&i.WorkloadType,
			&i.Namespace,
			&i.Cluster,
			&i.ImageName,
			&i.ImageTag,
			&i.LatestVersion,
			&i.Package,
			&i.CveID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SeveritySince,
			&i.LastSeverity,
			&i.CveTitle,
			&i.CveDesc,
			&i.CveLink,
			&i.Severity,
			&i.CveCreatedAt,
			&i.CveUpdatedAt,
			&i.Suppressed,
			&i.Reason,
			&i.ReasonText,
			&i.SuppressedBy,
			&i.SuppressedAt,
			&i.CvssScore,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkloadsForVulnerabilityById = `-- name: ListWorkloadsForVulnerabilityById :many
SELECT w.id,
       w.cluster,
       w.namespace,
       w.name,
       w.workload_type,
       w.image_name,
       w.image_tag
FROM workloads w
         JOIN vulnerabilities v
              ON v.image_name = w.image_name
                  AND v.image_tag = w.image_tag
WHERE v.id = $1
ORDER BY w.cluster, w.namespace, w.name
`

type ListWorkloadsForVulnerabilityByIdRow struct {
	ID           pgtype.UUID
	Cluster      string
	Namespace    string
	Name         string
	WorkloadType string
	ImageName    string
	ImageTag     string
}

func (q *Queries) ListWorkloadsForVulnerabilityById(ctx context.Context, vulnerabilityID pgtype.UUID) ([]*ListWorkloadsForVulnerabilityByIdRow, error) {
	rows, err := q.db.Query(ctx, listWorkloadsForVulnerabilityById, vulnerabilityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListWorkloadsForVulnerabilityByIdRow{}
	for rows.Next() {
		var i ListWorkloadsForVulnerabilityByIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Cluster,
			&i.Namespace,
			&i.Name,
			&i.WorkloadType,
			&i.ImageName,
			&i.ImageTag,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const suppressVulnerability = `-- name: SuppressVulnerability :exec
INSERT INTO suppressed_vulnerabilities(image_name,
                                       package,
                                       cve_id,
                                       suppressed,
                                       suppressed_by,
                                       reason,
                                       reason_text)
VALUES ($1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7) ON CONFLICT
ON CONSTRAINT image_name_package_cve_id DO
UPDATE
    SET
        suppressed = EXCLUDED.suppressed,
    suppressed_by = EXCLUDED.suppressed_by,
    reason = EXCLUDED.reason,
    reason_text = EXCLUDED.reason_text,
    updated_at = NOW()
WHERE
    suppressed_vulnerabilities.suppressed     IS DISTINCT FROM EXCLUDED.suppressed OR
    suppressed_vulnerabilities.suppressed_by  IS DISTINCT FROM EXCLUDED.suppressed_by OR
    suppressed_vulnerabilities.reason         IS DISTINCT FROM EXCLUDED.reason OR
    suppressed_vulnerabilities.reason_text    IS DISTINCT FROM EXCLUDED.reason_text
`

type SuppressVulnerabilityParams struct {
	ImageName    string
	Package      string
	CveID        string
	Suppressed   bool
	SuppressedBy string
	Reason       VulnerabilitySuppressReason
	ReasonText   string
}

func (q *Queries) SuppressVulnerability(ctx context.Context, arg SuppressVulnerabilityParams) error {
	_, err := q.db.Exec(ctx, suppressVulnerability,
		arg.ImageName,
		arg.Package,
		arg.CveID,
		arg.Suppressed,
		arg.SuppressedBy,
		arg.Reason,
		arg.ReasonText,
	)
	return err
}
