// Code generated by sqlc. DO NOT EDIT.
// source: vulnerbility_summary.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countVulnerabilitySummaries = `-- name: CountVulnerabilitySummaries :one
SELECT COUNT(*) AS total
FROM workloads w
         LEFT JOIN vulnerability_summary v
                   ON w.image_name = v.image_name AND w.image_tag = v.image_tag
WHERE
    (CASE WHEN $1::TEXT is not null THEN w.cluster = $1::TEXT ELSE TRUE END)
  AND (CASE WHEN $2::TEXT is not null THEN w.namespace = $2::TEXT ELSE TRUE END)
  AND (CASE WHEN $3::TEXT is not null THEN w.workload_type = $3::TEXT ELSE TRUE END)
  AND (CASE WHEN $4::TEXT is not null THEN w.name = $4::TEXT ELSE TRUE END)
  AND (CASE WHEN $5::TEXT is not null THEN v.image_name = $5::TEXT ELSE TRUE END)
  AND (CASE WHEN $6::TEXT is not null THEN v.image_tag = $6::TEXT ELSE TRUE END)
`

type CountVulnerabilitySummariesParams struct {
	Cluster      *string
	Namespace    *string
	WorkloadType *string
	WorkloadName *string
	ImageName    *string
	ImageTag     *string
}

func (q *Queries) CountVulnerabilitySummaries(ctx context.Context, arg CountVulnerabilitySummariesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countVulnerabilitySummaries,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadType,
		arg.WorkloadName,
		arg.ImageName,
		arg.ImageTag,
	)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countVulnerabilitySummaryHistory = `-- name: CountVulnerabilitySummaryHistory :one
SELECT COUNT(*) AS total
FROM workloads w
         LEFT JOIN vulnerability_summary v
                   ON w.image_name = v.image_name
WHERE
    (CASE WHEN $1::TEXT is not null THEN w.cluster = $1::TEXT ELSE TRUE END)
  AND (CASE WHEN $2::TEXT is not null THEN w.namespace = $2::TEXT ELSE TRUE END)
  AND (CASE WHEN $3::TEXT is not null THEN w.workload_type = $3::TEXT ELSE TRUE END)
  AND (CASE WHEN $4::TEXT is not null THEN w.name = $4::TEXT ELSE TRUE END)
  AND (CASE WHEN $5::TEXT is not null THEN v.image_name = $5::TEXT ELSE TRUE END)
  AND (CASE WHEN $6::TEXT is not null THEN v.image_tag = $6::TEXT ELSE TRUE END)
`

type CountVulnerabilitySummaryHistoryParams struct {
	Cluster      *string
	Namespace    *string
	WorkloadType *string
	WorkloadName *string
	ImageName    *string
	ImageTag     *string
}

func (q *Queries) CountVulnerabilitySummaryHistory(ctx context.Context, arg CountVulnerabilitySummaryHistoryParams) (int64, error) {
	row := q.db.QueryRow(ctx, countVulnerabilitySummaryHistory,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadType,
		arg.WorkloadName,
		arg.ImageName,
		arg.ImageTag,
	)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createVulnerabilitySummary = `-- name: CreateVulnerabilitySummary :one
INSERT INTO
    vulnerability_summary (image_name, image_tag, critical, high, medium, low, unassigned, risk_score)
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING
    id, image_name, image_tag, critical, high, medium, low, unassigned, risk_score, created_at, updated_at
`

type CreateVulnerabilitySummaryParams struct {
	ImageName  string
	ImageTag   string
	Critical   int32
	High       int32
	Medium     int32
	Low        int32
	Unassigned int32
	RiskScore  int32
}

func (q *Queries) CreateVulnerabilitySummary(ctx context.Context, arg CreateVulnerabilitySummaryParams) (*VulnerabilitySummary, error) {
	row := q.db.QueryRow(ctx, createVulnerabilitySummary,
		arg.ImageName,
		arg.ImageTag,
		arg.Critical,
		arg.High,
		arg.Medium,
		arg.Low,
		arg.Unassigned,
		arg.RiskScore,
	)
	var i VulnerabilitySummary
	err := row.Scan(
		&i.ID,
		&i.ImageName,
		&i.ImageTag,
		&i.Critical,
		&i.High,
		&i.Medium,
		&i.Low,
		&i.Unassigned,
		&i.RiskScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getVulnerabilitySummary = `-- name: GetVulnerabilitySummary :one
WITH filtered_workloads AS (
    SELECT w.id, w.image_name, w.image_tag
    FROM workloads w
    WHERE
        ($1::TEXT IS NULL OR w.cluster = $1::TEXT)
      AND ($2::TEXT IS NULL OR w.namespace = $2::TEXT)
      AND ($3::TEXT IS NULL OR w.workload_type = $3::TEXT)
      AND ($4::TEXT IS NULL OR w.name = $4::TEXT)
)
SELECT
    CAST(COUNT(DISTINCT fw.id) AS INT4) AS workload_count,
    CAST(COUNT(DISTINCT CASE WHEN v.image_name IS NOT NULL THEN fw.id END) AS INT4) AS workload_with_sbom,
    CAST(COALESCE(SUM(v.critical), 0) AS INT4) AS critical_vulnerabilities,
    CAST(COALESCE(SUM(v.high), 0) AS INT4) AS high_vulnerabilities,
    CAST(COALESCE(SUM(v.medium), 0) AS INT4) AS medium_vulnerabilities,
    CAST(COALESCE(SUM(v.low), 0) AS INT4) AS low_vulnerabilities,
    CAST(COALESCE(SUM(v.unassigned), 0) AS INT4) AS unassigned_vulnerabilities,
    CAST(COALESCE(SUM(v.risk_score), 0) AS INT4) AS total_risk_score
FROM filtered_workloads fw
         LEFT JOIN vulnerability_summary v
                   ON fw.image_name = v.image_name AND fw.image_tag = v.image_tag
`

type GetVulnerabilitySummaryParams struct {
	Cluster      *string
	Namespace    *string
	WorkloadType *string
	WorkloadName *string
}

type GetVulnerabilitySummaryRow struct {
	WorkloadCount             int32
	WorkloadWithSbom          int32
	CriticalVulnerabilities   int32
	HighVulnerabilities       int32
	MediumVulnerabilities     int32
	LowVulnerabilities        int32
	UnassignedVulnerabilities int32
	TotalRiskScore            int32
}

func (q *Queries) GetVulnerabilitySummary(ctx context.Context, arg GetVulnerabilitySummaryParams) (*GetVulnerabilitySummaryRow, error) {
	row := q.db.QueryRow(ctx, getVulnerabilitySummary,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadType,
		arg.WorkloadName,
	)
	var i GetVulnerabilitySummaryRow
	err := row.Scan(
		&i.WorkloadCount,
		&i.WorkloadWithSbom,
		&i.CriticalVulnerabilities,
		&i.HighVulnerabilities,
		&i.MediumVulnerabilities,
		&i.LowVulnerabilities,
		&i.UnassignedVulnerabilities,
		&i.TotalRiskScore,
	)
	return &i, err
}

const getVulnerabilitySummaryForImage = `-- name: GetVulnerabilitySummaryForImage :one
SELECT id, image_name, image_tag, critical, high, medium, low, unassigned, risk_score, created_at, updated_at FROM vulnerability_summary
WHERE image_name = $1
  AND image_tag = $2
`

type GetVulnerabilitySummaryForImageParams struct {
	ImageName string
	ImageTag  string
}

func (q *Queries) GetVulnerabilitySummaryForImage(ctx context.Context, arg GetVulnerabilitySummaryForImageParams) (*VulnerabilitySummary, error) {
	row := q.db.QueryRow(ctx, getVulnerabilitySummaryForImage, arg.ImageName, arg.ImageTag)
	var i VulnerabilitySummary
	err := row.Scan(
		&i.ID,
		&i.ImageName,
		&i.ImageTag,
		&i.Critical,
		&i.High,
		&i.Medium,
		&i.Low,
		&i.Unassigned,
		&i.RiskScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listAllVulnerabilitySummaries = `-- name: ListAllVulnerabilitySummaries :many
SELECT id, image_name, image_tag, critical, high, medium, low, unassigned, risk_score, created_at, updated_at FROM vulnerability_summary
ORDER BY
    CASE
        WHEN $1::TEXT = 'risk_score:asc' THEN LOWER(vulnerability_summary.risk_score)
END ASC,
	CASE
		WHEN $1::TEXT = 'risk_score:desc' THEN LOWER(vulnerability_summary.risk_score)
END DESC,
	vulnerability_summary.risk_score,
	vulnerability_summary.critical ASC
LIMIT
	$3
OFFSET
	$2
`

type ListAllVulnerabilitySummariesParams struct {
	OrderBy string
	Offset  int32
	Limit   int32
}

func (q *Queries) ListAllVulnerabilitySummaries(ctx context.Context, arg ListAllVulnerabilitySummariesParams) ([]*VulnerabilitySummary, error) {
	rows, err := q.db.Query(ctx, listAllVulnerabilitySummaries, arg.OrderBy, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*VulnerabilitySummary{}
	for rows.Next() {
		var i VulnerabilitySummary
		if err := rows.Scan(
			&i.ID,
			&i.ImageName,
			&i.ImageTag,
			&i.Critical,
			&i.High,
			&i.Medium,
			&i.Low,
			&i.Unassigned,
			&i.RiskScore,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVulnerabilitySummaries = `-- name: ListVulnerabilitySummaries :many
SELECT
    w.id,
    w.name AS workload_name,
    w.workload_type,
    w.namespace,
    w.cluster,
    w.image_name,
    w.image_tag,
    v.critical,
    v.high,
    v.medium,
    v.low,
    v.unassigned,
    v.risk_score,
    w.created_at AS workload_created_at,
    w.updated_at AS workload_updated_at,
    v.created_at AS summary_created_at,
    v.updated_at AS summary_updated_at,
    CASE WHEN v.image_name IS NOT NULL THEN TRUE ELSE FALSE END AS has_sbom
FROM workloads w
         LEFT JOIN vulnerability_summary v
                   ON w.image_name = v.image_name AND w.image_tag = v.image_tag
WHERE
    (CASE WHEN $1::TEXT is not null THEN w.cluster = $1::TEXT ELSE TRUE END)
  AND (CASE WHEN $2::TEXT is not null THEN w.namespace = $2::TEXT ELSE TRUE END)
  AND (CASE WHEN $3::TEXT is not null THEN w.workload_type = $3::TEXT ELSE TRUE END)
  AND (CASE WHEN $4::TEXT is not null THEN w.name = $4::TEXT ELSE TRUE END)
  AND (CASE WHEN $5::TEXT is not null THEN v.image_name = $5::TEXT ELSE TRUE END)
  AND (CASE WHEN $6::TEXT is not null THEN v.image_tag = $6::TEXT ELSE TRUE END)
ORDER BY
    CASE WHEN $7 = 'workload_asc' THEN w.name END ASC,
    CASE WHEN $7 = 'workload_desc' THEN w.name END DESC,
    CASE WHEN $7 = 'namespace_asc' THEN namespace END ASC,
    CASE WHEN $7 = 'namespace_desc' THEN namespace END DESC,
    CASE WHEN $7 = 'cluster_asc' THEN cluster END ASC,
    CASE WHEN $7 = 'cluster_desc' THEN cluster END DESC,
    CASE WHEN $7 = 'critical_asc' THEN v.critical END ASC,
    CASE WHEN $7 = 'critical_desc' THEN v.critical END DESC,
    CASE WHEN $7 = 'high_asc' THEN v.high END ASC,
    CASE WHEN $7 = 'high_desc' THEN v.high END DESC,
    CASE WHEN $7 = 'medium_asc' THEN v.medium END ASC,
    CASE WHEN $7 = 'medium_desc' THEN v.medium END DESC,
    CASE WHEN $7 = 'low_asc' THEN v.low END ASC,
    CASE WHEN $7 = 'low_desc' THEN v.low END DESC,
    CASE WHEN $7 = 'unassigned_asc' THEN v.unassigned END ASC,
    CASE WHEN $7 = 'unassigned_desc' THEN v.unassigned END DESC,
    CASE WHEN $7 = 'risk_score_asc' THEN v.risk_score END ASC,
    CASE WHEN $7 = 'risk_score_desc' THEN v.risk_score END DESC,
 v.id ASC
LIMIT
    $9
OFFSET
    $8
`

type ListVulnerabilitySummariesParams struct {
	Cluster      *string
	Namespace    *string
	WorkloadType *string
	WorkloadName *string
	ImageName    *string
	ImageTag     *string
	OrderBy      interface{}
	Offset       int32
	Limit        int32
}

type ListVulnerabilitySummariesRow struct {
	ID                pgtype.UUID
	WorkloadName      string
	WorkloadType      string
	Namespace         string
	Cluster           string
	ImageName         string
	ImageTag          string
	Critical          *int32
	High              *int32
	Medium            *int32
	Low               *int32
	Unassigned        *int32
	RiskScore         *int32
	WorkloadCreatedAt pgtype.Timestamptz
	WorkloadUpdatedAt pgtype.Timestamptz
	SummaryCreatedAt  pgtype.Timestamptz
	SummaryUpdatedAt  pgtype.Timestamptz
	HasSbom           bool
}

func (q *Queries) ListVulnerabilitySummaries(ctx context.Context, arg ListVulnerabilitySummariesParams) ([]*ListVulnerabilitySummariesRow, error) {
	rows, err := q.db.Query(ctx, listVulnerabilitySummaries,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadType,
		arg.WorkloadName,
		arg.ImageName,
		arg.ImageTag,
		arg.OrderBy,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListVulnerabilitySummariesRow{}
	for rows.Next() {
		var i ListVulnerabilitySummariesRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkloadName,
			&i.WorkloadType,
			&i.Namespace,
			&i.Cluster,
			&i.ImageName,
			&i.ImageTag,
			&i.Critical,
			&i.High,
			&i.Medium,
			&i.Low,
			&i.Unassigned,
			&i.RiskScore,
			&i.WorkloadCreatedAt,
			&i.WorkloadUpdatedAt,
			&i.SummaryCreatedAt,
			&i.SummaryUpdatedAt,
			&i.HasSbom,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVulnerabilitySummaryHistory = `-- name: ListVulnerabilitySummaryHistory :many
SELECT
    w.id,
    w.name AS workload_name,
    w.workload_type,
    w.namespace,
    w.cluster,
    w.image_name,
    w.image_tag,
    v.critical,
    v.high,
    v.medium,
    v.low,
    v.unassigned,
    v.risk_score,
    w.created_at AS workload_created_at,
    w.updated_at AS workload_updated_at,
    v.created_at AS summary_created_at,
    v.updated_at AS summary_updated_at,
    CASE WHEN v.image_name IS NOT NULL THEN TRUE ELSE FALSE END AS has_sbom
FROM workloads w
         LEFT JOIN vulnerability_summary v
                   ON w.image_name = v.image_name
WHERE
  v.updated_at > $1::TIMESTAMP WITH TIME ZONE
  AND (CASE WHEN $2::TEXT is not null THEN w.cluster = $2::TEXT ELSE TRUE END)
  AND (CASE WHEN $3::TEXT is not null THEN w.namespace = $3::TEXT ELSE TRUE END)
  AND (CASE WHEN $4::TEXT is not null THEN w.workload_type = $4::TEXT ELSE TRUE END)
  AND (CASE WHEN $5::TEXT is not null THEN w.name = $5::TEXT ELSE TRUE END)
  AND (CASE WHEN $6::TEXT is not null THEN v.image_name = $6::TEXT ELSE TRUE END)
  AND (CASE WHEN $7::TEXT is not null THEN v.image_tag = $7::TEXT ELSE TRUE END)
ORDER BY
    CASE WHEN $8 = 'workload_asc' THEN w.name END ASC,
    CASE WHEN $8 = 'workload_desc' THEN w.name END DESC,
    CASE WHEN $8 = 'namespace_asc' THEN namespace END ASC,
    CASE WHEN $8 = 'namespace_desc' THEN namespace END DESC,
    CASE WHEN $8 = 'cluster_asc' THEN cluster END ASC,
    CASE WHEN $8 = 'cluster_desc' THEN cluster END DESC,
    CASE WHEN $8 = 'critical_asc' THEN v.critical END ASC,
    CASE WHEN $8 = 'critical_desc' THEN v.critical END DESC,
    CASE WHEN $8 = 'high_asc' THEN v.high END ASC,
    CASE WHEN $8 = 'high_desc' THEN v.high END DESC,
    CASE WHEN $8 = 'medium_asc' THEN v.medium END ASC,
    CASE WHEN $8 = 'medium_desc' THEN v.medium END DESC,
    CASE WHEN $8 = 'low_asc' THEN v.low END ASC,
    CASE WHEN $8 = 'low_desc' THEN v.low END DESC,
    CASE WHEN $8 = 'unassigned_asc' THEN v.unassigned END ASC,
    CASE WHEN $8 = 'unassigned_desc' THEN v.unassigned END DESC,
    CASE WHEN $8 = 'risk_score_asc' THEN v.risk_score END ASC,
    CASE WHEN $8 = 'risk_score_desc' THEN v.risk_score END DESC,
    v.updated_at DESC, v.id DESC
    LIMIT
    $10
OFFSET
    $9
`

type ListVulnerabilitySummaryHistoryParams struct {
	From         pgtype.Timestamptz
	Cluster      *string
	Namespace    *string
	WorkloadType *string
	WorkloadName *string
	ImageName    *string
	ImageTag     *string
	OrderBy      interface{}
	Offset       int32
	Limit        int32
}

type ListVulnerabilitySummaryHistoryRow struct {
	ID                pgtype.UUID
	WorkloadName      string
	WorkloadType      string
	Namespace         string
	Cluster           string
	ImageName         string
	ImageTag          string
	Critical          *int32
	High              *int32
	Medium            *int32
	Low               *int32
	Unassigned        *int32
	RiskScore         *int32
	WorkloadCreatedAt pgtype.Timestamptz
	WorkloadUpdatedAt pgtype.Timestamptz
	SummaryCreatedAt  pgtype.Timestamptz
	SummaryUpdatedAt  pgtype.Timestamptz
	HasSbom           bool
}

func (q *Queries) ListVulnerabilitySummaryHistory(ctx context.Context, arg ListVulnerabilitySummaryHistoryParams) ([]*ListVulnerabilitySummaryHistoryRow, error) {
	rows, err := q.db.Query(ctx, listVulnerabilitySummaryHistory,
		arg.From,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadType,
		arg.WorkloadName,
		arg.ImageName,
		arg.ImageTag,
		arg.OrderBy,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListVulnerabilitySummaryHistoryRow{}
	for rows.Next() {
		var i ListVulnerabilitySummaryHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkloadName,
			&i.WorkloadType,
			&i.Namespace,
			&i.Cluster,
			&i.ImageName,
			&i.ImageTag,
			&i.Critical,
			&i.High,
			&i.Medium,
			&i.Low,
			&i.Unassigned,
			&i.RiskScore,
			&i.WorkloadCreatedAt,
			&i.WorkloadUpdatedAt,
			&i.SummaryCreatedAt,
			&i.SummaryUpdatedAt,
			&i.HasSbom,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVulnerabilitySummary = `-- name: UpdateVulnerabilitySummary :one
UPDATE vulnerability_summary
SET
    critical = COALESCE($1, critical),
    high = COALESCE($2, high),
    medium = COALESCE($3, medium),
    low = COALESCE($4, low),
    unassigned = COALESCE($5, unassigned),
    risk_score = COALESCE($6, risk_score)
WHERE
    vulnerability_summary.id = $7
RETURNING
    id, image_name, image_tag, critical, high, medium, low, unassigned, risk_score, created_at, updated_at
`

type UpdateVulnerabilitySummaryParams struct {
	Critical   *int32
	High       *int32
	Medium     *int32
	Low        *int32
	Unassigned *int32
	RiskScore  *int32
	ID         pgtype.UUID
}

func (q *Queries) UpdateVulnerabilitySummary(ctx context.Context, arg UpdateVulnerabilitySummaryParams) (*VulnerabilitySummary, error) {
	row := q.db.QueryRow(ctx, updateVulnerabilitySummary,
		arg.Critical,
		arg.High,
		arg.Medium,
		arg.Low,
		arg.Unassigned,
		arg.RiskScore,
		arg.ID,
	)
	var i VulnerabilitySummary
	err := row.Scan(
		&i.ID,
		&i.ImageName,
		&i.ImageTag,
		&i.Critical,
		&i.High,
		&i.Medium,
		&i.Low,
		&i.Unassigned,
		&i.RiskScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
