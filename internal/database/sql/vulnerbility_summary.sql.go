// Code generated by sqlc. DO NOT EDIT.
// source: vulnerbility_summary.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createVulnerabilitySummary = `-- name: CreateVulnerabilitySummary :one
INSERT INTO
    vulnerability_summary (image_name, image_tag, critical, high, medium, low, unassigned, risk_score)
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING
    id, image_name, image_tag, critical, high, medium, low, unassigned, risk_score, created_at, updated_at
`

type CreateVulnerabilitySummaryParams struct {
	ImageName  string
	ImageTag   string
	Critical   int32
	High       int32
	Medium     int32
	Low        int32
	Unassigned int32
	RiskScore  int32
}

func (q *Queries) CreateVulnerabilitySummary(ctx context.Context, arg CreateVulnerabilitySummaryParams) (*VulnerabilitySummary, error) {
	row := q.db.QueryRow(ctx, createVulnerabilitySummary,
		arg.ImageName,
		arg.ImageTag,
		arg.Critical,
		arg.High,
		arg.Medium,
		arg.Low,
		arg.Unassigned,
		arg.RiskScore,
	)
	var i VulnerabilitySummary
	err := row.Scan(
		&i.ID,
		&i.ImageName,
		&i.ImageTag,
		&i.Critical,
		&i.High,
		&i.Medium,
		&i.Low,
		&i.Unassigned,
		&i.RiskScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listVulnerabilitySummary = `-- name: ListVulnerabilitySummary :many
SELECT id, image_name, image_tag, critical, high, medium, low, unassigned, risk_score, created_at, updated_at FROM vulnerability_summary
ORDER BY
    CASE
        WHEN $1::TEXT = 'risk_score:asc' THEN LOWER(vulnerability_summary.risk_score)
END ASC,
	CASE
		WHEN $1::TEXT = 'risk_score:desc' THEN LOWER(vulnerability_summary.risk_score)
END DESC,
	vulnerability_summary.risk_score,
	vulnerability_summary.critical ASC
LIMIT
	$3
OFFSET
	$2
`

type ListVulnerabilitySummaryParams struct {
	OrderBy string
	Offset  int32
	Limit   int32
}

func (q *Queries) ListVulnerabilitySummary(ctx context.Context, arg ListVulnerabilitySummaryParams) ([]*VulnerabilitySummary, error) {
	rows, err := q.db.Query(ctx, listVulnerabilitySummary, arg.OrderBy, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*VulnerabilitySummary{}
	for rows.Next() {
		var i VulnerabilitySummary
		if err := rows.Scan(
			&i.ID,
			&i.ImageName,
			&i.ImageTag,
			&i.Critical,
			&i.High,
			&i.Medium,
			&i.Low,
			&i.Unassigned,
			&i.RiskScore,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVulnerabilitySummary = `-- name: UpdateVulnerabilitySummary :one
UPDATE vulnerability_summary
SET
    critical = COALESCE($1, critical),
    high = COALESCE($2, high),
    medium = COALESCE($3, medium),
    low = COALESCE($4, low),
    unassigned = COALESCE($5, unassigned),
    risk_score = COALESCE($6, risk_score)
WHERE
    vulnerability_summary.id = $7
RETURNING
    id, image_name, image_tag, critical, high, medium, low, unassigned, risk_score, created_at, updated_at
`

type UpdateVulnerabilitySummaryParams struct {
	Critical   *int32
	High       *int32
	Medium     *int32
	Low        *int32
	Unassigned *int32
	RiskScore  *int32
	ID         pgtype.UUID
}

func (q *Queries) UpdateVulnerabilitySummary(ctx context.Context, arg UpdateVulnerabilitySummaryParams) (*VulnerabilitySummary, error) {
	row := q.db.QueryRow(ctx, updateVulnerabilitySummary,
		arg.Critical,
		arg.High,
		arg.Medium,
		arg.Low,
		arg.Unassigned,
		arg.RiskScore,
		arg.ID,
	)
	var i VulnerabilitySummary
	err := row.Scan(
		&i.ID,
		&i.ImageName,
		&i.ImageTag,
		&i.Critical,
		&i.High,
		&i.Medium,
		&i.Low,
		&i.Unassigned,
		&i.RiskScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
