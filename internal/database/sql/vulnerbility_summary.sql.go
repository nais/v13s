// Code generated by sqlc. DO NOT EDIT.
// source: vulnerbility_summary.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createVulnerabilitySummary = `-- name: CreateVulnerabilitySummary :one
INSERT INTO
    vulnerability_summary (image_name, image_tag, critical, high, medium, low, unassigned, risk_score)
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING
    id, image_name, image_tag, critical, high, medium, low, unassigned, risk_score, created_at, updated_at
`

type CreateVulnerabilitySummaryParams struct {
	ImageName  string
	ImageTag   string
	Critical   int32
	High       int32
	Medium     int32
	Low        int32
	Unassigned int32
	RiskScore  int32
}

func (q *Queries) CreateVulnerabilitySummary(ctx context.Context, arg CreateVulnerabilitySummaryParams) (*VulnerabilitySummary, error) {
	row := q.db.QueryRow(ctx, createVulnerabilitySummary,
		arg.ImageName,
		arg.ImageTag,
		arg.Critical,
		arg.High,
		arg.Medium,
		arg.Low,
		arg.Unassigned,
		arg.RiskScore,
	)
	var i VulnerabilitySummary
	err := row.Scan(
		&i.ID,
		&i.ImageName,
		&i.ImageTag,
		&i.Critical,
		&i.High,
		&i.Medium,
		&i.Low,
		&i.Unassigned,
		&i.RiskScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getVulnerabilitySummary = `-- name: GetVulnerabilitySummary :one
WITH filtered_workloads AS (
    SELECT w.id, w.image_name, w.image_tag
    FROM workloads w
    WHERE
        ($1::TEXT IS NULL OR w.cluster = $1::TEXT)
      AND ($2::TEXT IS NULL OR w.namespace = $2::TEXT)
      AND ($3::TEXT IS NULL OR w.workload_type = $3::TEXT)
      AND ($4::TEXT IS NULL OR w.name = $4::TEXT)
)
SELECT
    CAST(COUNT(DISTINCT fw.id) AS INT4) AS workload_count,
    CAST(COUNT(DISTINCT CASE WHEN v.image_name IS NOT NULL THEN fw.id END) AS INT4) AS workload_with_sbom,
    CAST(COALESCE(SUM(v.critical), 0) AS INT4) AS critical_vulnerabilities,
    CAST(COALESCE(SUM(v.high), 0) AS INT4) AS high_vulnerabilities,
    CAST(COALESCE(SUM(v.medium), 0) AS INT4) AS medium_vulnerabilities,
    CAST(COALESCE(SUM(v.low), 0) AS INT4) AS low_vulnerabilities,
    CAST(COALESCE(SUM(v.unassigned), 0) AS INT4) AS unassigned_vulnerabilities,
    CAST(COALESCE(SUM(v.risk_score), 0) AS INT4) AS total_risk_score
FROM filtered_workloads fw
         LEFT JOIN vulnerability_summary v
                   ON fw.image_name = v.image_name AND fw.image_tag = v.image_tag
`

type GetVulnerabilitySummaryParams struct {
	Cluster      *string
	Namespace    *string
	WorkloadType *string
	WorkloadName *string
}

type GetVulnerabilitySummaryRow struct {
	WorkloadCount             int32
	WorkloadWithSbom          int32
	CriticalVulnerabilities   int32
	HighVulnerabilities       int32
	MediumVulnerabilities     int32
	LowVulnerabilities        int32
	UnassignedVulnerabilities int32
	TotalRiskScore            int32
}

func (q *Queries) GetVulnerabilitySummary(ctx context.Context, arg GetVulnerabilitySummaryParams) (*GetVulnerabilitySummaryRow, error) {
	row := q.db.QueryRow(ctx, getVulnerabilitySummary,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadType,
		arg.WorkloadName,
	)
	var i GetVulnerabilitySummaryRow
	err := row.Scan(
		&i.WorkloadCount,
		&i.WorkloadWithSbom,
		&i.CriticalVulnerabilities,
		&i.HighVulnerabilities,
		&i.MediumVulnerabilities,
		&i.LowVulnerabilities,
		&i.UnassignedVulnerabilities,
		&i.TotalRiskScore,
	)
	return &i, err
}

const getVulnerabilitySummaryForImage = `-- name: GetVulnerabilitySummaryForImage :one
SELECT id, image_name, image_tag, critical, high, medium, low, unassigned, risk_score, created_at, updated_at FROM vulnerability_summary
WHERE image_name = $1
  AND image_tag = $2
`

type GetVulnerabilitySummaryForImageParams struct {
	ImageName string
	ImageTag  string
}

func (q *Queries) GetVulnerabilitySummaryForImage(ctx context.Context, arg GetVulnerabilitySummaryForImageParams) (*VulnerabilitySummary, error) {
	row := q.db.QueryRow(ctx, getVulnerabilitySummaryForImage, arg.ImageName, arg.ImageTag)
	var i VulnerabilitySummary
	err := row.Scan(
		&i.ID,
		&i.ImageName,
		&i.ImageTag,
		&i.Critical,
		&i.High,
		&i.Medium,
		&i.Low,
		&i.Unassigned,
		&i.RiskScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listAllVulnerabilitySummaries = `-- name: ListAllVulnerabilitySummaries :many
SELECT id, image_name, image_tag, critical, high, medium, low, unassigned, risk_score, created_at, updated_at FROM vulnerability_summary
ORDER BY
    CASE
        WHEN $1::TEXT = 'risk_score:asc' THEN LOWER(vulnerability_summary.risk_score)
END ASC,
	CASE
		WHEN $1::TEXT = 'risk_score:desc' THEN LOWER(vulnerability_summary.risk_score)
END DESC,
	vulnerability_summary.risk_score,
	vulnerability_summary.critical ASC
LIMIT
	$3
OFFSET
	$2
`

type ListAllVulnerabilitySummariesParams struct {
	OrderBy string
	Offset  int32
	Limit   int32
}

func (q *Queries) ListAllVulnerabilitySummaries(ctx context.Context, arg ListAllVulnerabilitySummariesParams) ([]*VulnerabilitySummary, error) {
	rows, err := q.db.Query(ctx, listAllVulnerabilitySummaries, arg.OrderBy, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*VulnerabilitySummary{}
	for rows.Next() {
		var i VulnerabilitySummary
		if err := rows.Scan(
			&i.ID,
			&i.ImageName,
			&i.ImageTag,
			&i.Critical,
			&i.High,
			&i.Medium,
			&i.Low,
			&i.Unassigned,
			&i.RiskScore,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVulnerabilitySummaries = `-- name: ListVulnerabilitySummaries :many
SELECT
    w.id,
    w.name AS workload_name,
    w.workload_type,
    w.namespace,
    w.cluster,
    w.image_name,
    w.image_tag,
    v.critical,
    v.high,
    v.medium,
    v.low,
    v.unassigned,
    v.risk_score,
    w.created_at AS workload_created_at,
    w.updated_at AS workload_updated_at,
    v.created_at AS vulnerability_created_at,
    v.updated_at AS vulnerability_updated_at,
    CASE WHEN v.image_name IS NOT NULL THEN TRUE ELSE FALSE END AS has_sbom
FROM workloads w
         LEFT JOIN vulnerability_summary v
                   ON w.image_name = v.image_name AND w.image_tag = v.image_tag
WHERE
    (CASE WHEN $1::TEXT is not null THEN w.cluster = $1::TEXT ELSE TRUE END)
  AND (CASE WHEN $2::TEXT is not null THEN w.namespace = $2::TEXT ELSE TRUE END)
  AND (CASE WHEN $3::TEXT is not null THEN w.workload_type = $3::TEXT ELSE TRUE END)
  AND (CASE WHEN $4::TEXT is not null THEN w.name = $4::TEXT ELSE TRUE END)
  AND (CASE WHEN $5::TEXT is not null THEN v.image_name = $5::TEXT ELSE TRUE END)
  AND (CASE WHEN $6::TEXT is not null THEN v.image_tag = $6::TEXT ELSE TRUE END)
ORDER BY v.critical DESC NULLS LAST, v.risk_score DESC NULLS LAST, w.updated_at DESC
LIMIT
    $8
OFFSET
    $7
`

type ListVulnerabilitySummariesParams struct {
	Cluster      *string
	Namespace    *string
	WorkloadType *string
	WorkloadName *string
	ImageName    *string
	ImageTag     *string
	Offset       int32
	Limit        int32
}

type ListVulnerabilitySummariesRow struct {
	ID                     pgtype.UUID
	WorkloadName           string
	WorkloadType           string
	Namespace              string
	Cluster                string
	ImageName              string
	ImageTag               string
	Critical               *int32
	High                   *int32
	Medium                 *int32
	Low                    *int32
	Unassigned             *int32
	RiskScore              *int32
	WorkloadCreatedAt      pgtype.Timestamptz
	WorkloadUpdatedAt      pgtype.Timestamptz
	VulnerabilityCreatedAt pgtype.Timestamptz
	VulnerabilityUpdatedAt pgtype.Timestamptz
	HasSbom                bool
}

func (q *Queries) ListVulnerabilitySummaries(ctx context.Context, arg ListVulnerabilitySummariesParams) ([]*ListVulnerabilitySummariesRow, error) {
	rows, err := q.db.Query(ctx, listVulnerabilitySummaries,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadType,
		arg.WorkloadName,
		arg.ImageName,
		arg.ImageTag,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListVulnerabilitySummariesRow{}
	for rows.Next() {
		var i ListVulnerabilitySummariesRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkloadName,
			&i.WorkloadType,
			&i.Namespace,
			&i.Cluster,
			&i.ImageName,
			&i.ImageTag,
			&i.Critical,
			&i.High,
			&i.Medium,
			&i.Low,
			&i.Unassigned,
			&i.RiskScore,
			&i.WorkloadCreatedAt,
			&i.WorkloadUpdatedAt,
			&i.VulnerabilityCreatedAt,
			&i.VulnerabilityUpdatedAt,
			&i.HasSbom,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVulnerabilitySummary = `-- name: UpdateVulnerabilitySummary :one
UPDATE vulnerability_summary
SET
    critical = COALESCE($1, critical),
    high = COALESCE($2, high),
    medium = COALESCE($3, medium),
    low = COALESCE($4, low),
    unassigned = COALESCE($5, unassigned),
    risk_score = COALESCE($6, risk_score)
WHERE
    vulnerability_summary.id = $7
RETURNING
    id, image_name, image_tag, critical, high, medium, low, unassigned, risk_score, created_at, updated_at
`

type UpdateVulnerabilitySummaryParams struct {
	Critical   *int32
	High       *int32
	Medium     *int32
	Low        *int32
	Unassigned *int32
	RiskScore  *int32
	ID         pgtype.UUID
}

func (q *Queries) UpdateVulnerabilitySummary(ctx context.Context, arg UpdateVulnerabilitySummaryParams) (*VulnerabilitySummary, error) {
	row := q.db.QueryRow(ctx, updateVulnerabilitySummary,
		arg.Critical,
		arg.High,
		arg.Medium,
		arg.Low,
		arg.Unassigned,
		arg.RiskScore,
		arg.ID,
	)
	var i VulnerabilitySummary
	err := row.Scan(
		&i.ID,
		&i.ImageName,
		&i.ImageTag,
		&i.Critical,
		&i.High,
		&i.Medium,
		&i.Low,
		&i.Unassigned,
		&i.RiskScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const upsertVulnerabilitySummary = `-- name: UpsertVulnerabilitySummary :exec
INSERT INTO vulnerability_summary(image_name,
                                  image_tag,
                                  critical,
                                  high,
                                  medium,
                                  low,
                                  unassigned,
                                  risk_score)
VALUES ($1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8) ON CONFLICT
ON CONSTRAINT image_name_tag DO
UPDATE
    SET critical = $3,
    high = $4,
    medium = $5,
    low = $6,
    unassigned = $7,
    risk_score = $8
`

type UpsertVulnerabilitySummaryParams struct {
	ImageName  string
	ImageTag   string
	Critical   int32
	High       int32
	Medium     int32
	Low        int32
	Unassigned int32
	RiskScore  int32
}

func (q *Queries) UpsertVulnerabilitySummary(ctx context.Context, arg UpsertVulnerabilitySummaryParams) error {
	_, err := q.db.Exec(ctx, upsertVulnerabilitySummary,
		arg.ImageName,
		arg.ImageTag,
		arg.Critical,
		arg.High,
		arg.Medium,
		arg.Low,
		arg.Unassigned,
		arg.RiskScore,
	)
	return err
}
