// Code generated by sqlc. DO NOT EDIT.
// source: vulnerbility_summary.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createVulnerabilitySummary = `-- name: CreateVulnerabilitySummary :one
INSERT INTO vulnerability_summary(
    image_name,
    image_tag,
    critical,
    high,
    medium,
    low,
    unassigned,
    risk_score)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8)
RETURNING
    id, image_name, image_tag, critical, high, medium, low, unassigned, risk_score, created_at, updated_at
`

type CreateVulnerabilitySummaryParams struct {
	ImageName  string
	ImageTag   string
	Critical   int32
	High       int32
	Medium     int32
	Low        int32
	Unassigned int32
	RiskScore  int32
}

func (q *Queries) CreateVulnerabilitySummary(ctx context.Context, arg CreateVulnerabilitySummaryParams) (*VulnerabilitySummary, error) {
	row := q.db.QueryRow(ctx, createVulnerabilitySummary,
		arg.ImageName,
		arg.ImageTag,
		arg.Critical,
		arg.High,
		arg.Medium,
		arg.Low,
		arg.Unassigned,
		arg.RiskScore,
	)
	var i VulnerabilitySummary
	err := row.Scan(
		&i.ID,
		&i.ImageName,
		&i.ImageTag,
		&i.Critical,
		&i.High,
		&i.Medium,
		&i.Low,
		&i.Unassigned,
		&i.RiskScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getLastSnapshotDateForVulnerabilitySummary = `-- name: GetLastSnapshotDateForVulnerabilitySummary :one
SELECT
    COALESCE(MAX(snapshot_date), '2025-01-01')::DATE AS last_snapshot
FROM
    vuln_daily_by_workload
`

func (q *Queries) GetLastSnapshotDateForVulnerabilitySummary(ctx context.Context) (pgtype.Date, error) {
	row := q.db.QueryRow(ctx, getLastSnapshotDateForVulnerabilitySummary)
	var last_snapshot pgtype.Date
	err := row.Scan(&last_snapshot)
	return last_snapshot, err
}

const getVulnerabilitySummary = `-- name: GetVulnerabilitySummary :one
WITH filtered_workloads AS (
    SELECT
        w.id,
        w.image_name,
        w.image_tag
    FROM
        workloads w
    WHERE ($1::TEXT IS NULL
        OR w.cluster = $1::TEXT)
    AND ($2::TEXT IS NULL
        OR w.namespace = $2::TEXT)
    AND ($3::TEXT[] IS NULL
        OR w.workload_type = ANY ($3::TEXT[]))
    AND ($4::TEXT IS NULL
        OR w.name = $4::TEXT))
SELECT
    CAST(COUNT(DISTINCT fw.id) AS INT4) AS workload_count,
    CAST(COUNT(DISTINCT CASE WHEN v.image_name IS NOT NULL THEN
                fw.id
            END) AS INT4) AS workload_with_sbom,
    CAST(COALESCE(SUM(v.critical), 0) AS INT4) AS critical,
    CAST(COALESCE(SUM(v.high), 0) AS INT4) AS high,
    CAST(COALESCE(SUM(v.medium), 0) AS INT4) AS medium,
    CAST(COALESCE(SUM(v.low), 0) AS INT4) AS low,
    CAST(COALESCE(SUM(v.unassigned), 0) AS INT4) AS unassigned,
    CAST(COALESCE(SUM(v.risk_score), 0) AS INT4) AS risk_score,
    MAX(v.updated_at)::TIMESTAMPTZ AS updated_at
FROM
    filtered_workloads fw
    LEFT JOIN vulnerability_summary v ON fw.image_name = v.image_name
        AND fw.image_tag = v.image_tag
`

type GetVulnerabilitySummaryParams struct {
	Cluster       *string
	Namespace     *string
	WorkloadTypes []string
	WorkloadName  *string
}

type GetVulnerabilitySummaryRow struct {
	WorkloadCount    int32
	WorkloadWithSbom int32
	Critical         int32
	High             int32
	Medium           int32
	Low              int32
	Unassigned       int32
	RiskScore        int32
	UpdatedAt        pgtype.Timestamptz
}

func (q *Queries) GetVulnerabilitySummary(ctx context.Context, arg GetVulnerabilitySummaryParams) (*GetVulnerabilitySummaryRow, error) {
	row := q.db.QueryRow(ctx, getVulnerabilitySummary,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadTypes,
		arg.WorkloadName,
	)
	var i GetVulnerabilitySummaryRow
	err := row.Scan(
		&i.WorkloadCount,
		&i.WorkloadWithSbom,
		&i.Critical,
		&i.High,
		&i.Medium,
		&i.Low,
		&i.Unassigned,
		&i.RiskScore,
		&i.UpdatedAt,
	)
	return &i, err
}

const getVulnerabilitySummaryForImage = `-- name: GetVulnerabilitySummaryForImage :one
SELECT
    id, image_name, image_tag, critical, high, medium, low, unassigned, risk_score, created_at, updated_at
FROM
    vulnerability_summary
WHERE
    image_name = $1
    AND image_tag = $2
`

type GetVulnerabilitySummaryForImageParams struct {
	ImageName string
	ImageTag  string
}

func (q *Queries) GetVulnerabilitySummaryForImage(ctx context.Context, arg GetVulnerabilitySummaryForImageParams) (*VulnerabilitySummary, error) {
	row := q.db.QueryRow(ctx, getVulnerabilitySummaryForImage, arg.ImageName, arg.ImageTag)
	var i VulnerabilitySummary
	err := row.Scan(
		&i.ID,
		&i.ImageName,
		&i.ImageTag,
		&i.Critical,
		&i.High,
		&i.Medium,
		&i.Low,
		&i.Unassigned,
		&i.RiskScore,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getVulnerabilitySummaryTimeSeries = `-- name: GetVulnerabilitySummaryTimeSeries :many
SELECT
    snapshot_date,
    SUM(workload_count)::INT4 AS workload_count,
    SUM(critical)::INT4 AS critical,
    SUM(high)::INT4 AS high,
    SUM(medium)::INT4 AS medium,
    SUM(low)::INT4 AS low,
    SUM(unassigned)::INT4 AS unassigned,
    SUM(total)::INT4 AS total,
    SUM(risk_score)::INT4 AS risk_score
FROM
    mv_vuln_summary_daily_by_workload
WHERE
    snapshot_date >= $1::TIMESTAMPTZ
    AND snapshot_date <= CURRENT_DATE
    AND ($2::TEXT IS NULL
        OR CLUSTER = $2::TEXT)
    AND ($3::TEXT IS NULL
        OR namespace = $3::TEXT)
    AND ($4::TEXT[] IS NULL
        OR workload_type = ANY ($4::TEXT[]))
    AND ($5::TEXT IS NULL
        OR workload_name = $5::TEXT)
GROUP BY
    snapshot_date
ORDER BY
    snapshot_date
`

type GetVulnerabilitySummaryTimeSeriesParams struct {
	Since         pgtype.Timestamptz
	Cluster       *string
	Namespace     *string
	WorkloadTypes []string
	WorkloadName  *string
}

type GetVulnerabilitySummaryTimeSeriesRow struct {
	SnapshotDate  pgtype.Date
	WorkloadCount int32
	Critical      int32
	High          int32
	Medium        int32
	Low           int32
	Unassigned    int32
	Total         int32
	RiskScore     int32
}

func (q *Queries) GetVulnerabilitySummaryTimeSeries(ctx context.Context, arg GetVulnerabilitySummaryTimeSeriesParams) ([]*GetVulnerabilitySummaryTimeSeriesRow, error) {
	rows, err := q.db.Query(ctx, getVulnerabilitySummaryTimeSeries,
		arg.Since,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadTypes,
		arg.WorkloadName,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetVulnerabilitySummaryTimeSeriesRow{}
	for rows.Next() {
		var i GetVulnerabilitySummaryTimeSeriesRow
		if err := rows.Scan(
			&i.SnapshotDate,
			&i.WorkloadCount,
			&i.Critical,
			&i.High,
			&i.Medium,
			&i.Low,
			&i.Unassigned,
			&i.Total,
			&i.RiskScore,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUpdatedWorkloadsWithSummaries = `-- name: ListUpdatedWorkloadsWithSummaries :many
SELECT
    w.cluster,
    w.namespace,
    w.name,
    w.image_name,
    w.image_tag,
    w.state AS workload_state,
    i.state AS image_state,
    s.critical,
    s.high,
    s.medium,
    s.low,
    s.unassigned,
    s.risk_score
FROM
    workloads w
    JOIN images i ON i.name = w.image_name
        AND i.tag = w.image_tag
    JOIN vulnerability_summary s ON s.image_name = w.image_name
        AND s.image_tag = w.image_tag
WHERE
    w.state = 'updated'
    AND i.state = 'updated'
ORDER BY
    w.cluster,
    w.namespace,
    w.name
`

type ListUpdatedWorkloadsWithSummariesRow struct {
	Cluster       string
	Namespace     string
	Name          string
	ImageName     string
	ImageTag      string
	WorkloadState WorkloadState
	ImageState    ImageState
	Critical      int32
	High          int32
	Medium        int32
	Low           int32
	Unassigned    int32
	RiskScore     int32
}

func (q *Queries) ListUpdatedWorkloadsWithSummaries(ctx context.Context) ([]*ListUpdatedWorkloadsWithSummariesRow, error) {
	rows, err := q.db.Query(ctx, listUpdatedWorkloadsWithSummaries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListUpdatedWorkloadsWithSummariesRow{}
	for rows.Next() {
		var i ListUpdatedWorkloadsWithSummariesRow
		if err := rows.Scan(
			&i.Cluster,
			&i.Namespace,
			&i.Name,
			&i.ImageName,
			&i.ImageTag,
			&i.WorkloadState,
			&i.ImageState,
			&i.Critical,
			&i.High,
			&i.Medium,
			&i.Low,
			&i.Unassigned,
			&i.RiskScore,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVulnerabilitySummaries = `-- name: ListVulnerabilitySummaries :many
WITH filtered_workloads AS (
    SELECT
        id, name, workload_type, namespace, cluster, image_name, image_tag, created_at, updated_at, state
    FROM
        workloads w
    WHERE ($4::TEXT IS NULL
        OR w.cluster = $4::TEXT)
    AND ($5::TEXT IS NULL
        OR w.namespace = $5::TEXT)
    AND ($6::TEXT[] IS NULL
        OR w.workload_type = ANY ($6::TEXT[]))
    AND ($7::TEXT IS NULL
        OR w.name = $7::TEXT)
),
vulnerability_data AS (
    SELECT
        v.id,
        w.name AS workload_name,
        w.workload_type,
        w.namespace,
        w.cluster,
        w.image_name AS current_image_name,
        w.image_tag AS current_image_tag,
        v.image_name,
        v.image_tag,
        v.critical,
        v.high,
        v.medium,
        v.low,
        v.unassigned,
        v.risk_score,
        w.created_at AS workload_created_at,
        w.updated_at AS workload_updated_at,
        v.created_at AS summary_created_at,
        v.updated_at AS summary_updated_at,
        CASE WHEN v.image_name IS NOT NULL THEN
            TRUE
        ELSE
            FALSE
        END AS has_sbom
    FROM
        filtered_workloads w
        LEFT JOIN vulnerability_summary v ON w.image_name = v.image_name
            AND (
                -- If no since join on image_tag, if since is set ignore image_tag
                CASE WHEN $8::TIMESTAMP WITH TIME ZONE IS NULL THEN
                    w.image_tag = v.image_tag
                ELSE
                    TRUE
                END)
    WHERE ($9::TEXT IS NULL
        OR v.image_name = $9::TEXT)
    AND ($10::TEXT IS NULL
        OR v.image_tag = $10::TEXT)
    AND ($8::TIMESTAMP WITH TIME ZONE IS NULL
        OR v.updated_at > $8::TIMESTAMP WITH TIME ZONE))
SELECT
    id, workload_name, workload_type, namespace, cluster, current_image_name, current_image_tag, image_name, image_tag, critical, high, medium, low, unassigned, risk_score, workload_created_at, workload_updated_at, summary_created_at, summary_updated_at, has_sbom,
(
        SELECT
            COUNT(*)
        FROM
            vulnerability_data) AS total_count
FROM
    vulnerability_data
ORDER BY
    CASE WHEN $1 = 'workload_asc' THEN
        workload_name
    END ASC,
    CASE WHEN $1 = 'workload_desc' THEN
        workload_name
    END DESC,
    CASE WHEN $1 = 'namespace_asc' THEN
        namespace
    END ASC,
    CASE WHEN $1 = 'namespace_desc' THEN
        namespace
    END DESC,
    CASE WHEN $1 = 'cluster_asc' THEN
        CLUSTER
    END ASC,
    CASE WHEN $1 = 'cluster_desc' THEN
        CLUSTER
    END DESC,
    CASE WHEN $1 = 'critical_asc' THEN
        COALESCE(critical, 999999)
    END ASC,
    CASE WHEN $1 = 'critical_desc' THEN
        COALESCE(critical, -1)
    END DESC,
    CASE WHEN $1 = 'high_asc' THEN
        COALESCE(high, 999999)
    END ASC,
    CASE WHEN $1 = 'high_desc' THEN
        COALESCE(high, -1)
    END DESC,
    CASE WHEN $1 = 'medium_asc' THEN
        COALESCE(medium, 999999)
    END ASC,
    CASE WHEN $1 = 'medium_desc' THEN
        COALESCE(medium, -1)
    END DESC,
    CASE WHEN $1 = 'low_asc' THEN
        COALESCE(low, 999999)
    END ASC,
    CASE WHEN $1 = 'low_desc' THEN
        COALESCE(low, -1)
    END DESC,
    CASE WHEN $1 = 'unassigned_asc' THEN
        COALESCE(unassigned, 999999)
    END ASC,
    CASE WHEN $1 = 'unassigned_desc' THEN
        COALESCE(unassigned, -1)
    END DESC,
    CASE WHEN $1 = 'risk_score_asc' THEN
        COALESCE(risk_score, 999999)
    END ASC,
    CASE WHEN $1 = 'risk_score_desc' THEN
        COALESCE(risk_score, -1)
    END DESC,
    summary_updated_at ASC,
    id DESC
LIMIT $3
    OFFSET $2
`

type ListVulnerabilitySummariesParams struct {
	OrderBy       interface{}
	Offset        int32
	Limit         int32
	Cluster       *string
	Namespace     *string
	WorkloadTypes []string
	WorkloadName  *string
	Since         pgtype.Timestamptz
	ImageName     *string
	ImageTag      *string
}

type ListVulnerabilitySummariesRow struct {
	ID                pgtype.UUID
	WorkloadName      string
	WorkloadType      string
	Namespace         string
	Cluster           string
	CurrentImageName  string
	CurrentImageTag   string
	ImageName         *string
	ImageTag          *string
	Critical          *int32
	High              *int32
	Medium            *int32
	Low               *int32
	Unassigned        *int32
	RiskScore         *int32
	WorkloadCreatedAt pgtype.Timestamptz
	WorkloadUpdatedAt pgtype.Timestamptz
	SummaryCreatedAt  pgtype.Timestamptz
	SummaryUpdatedAt  pgtype.Timestamptz
	HasSbom           bool
	TotalCount        int64
}

func (q *Queries) ListVulnerabilitySummaries(ctx context.Context, arg ListVulnerabilitySummariesParams) ([]*ListVulnerabilitySummariesRow, error) {
	rows, err := q.db.Query(ctx, listVulnerabilitySummaries,
		arg.OrderBy,
		arg.Offset,
		arg.Limit,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadTypes,
		arg.WorkloadName,
		arg.Since,
		arg.ImageName,
		arg.ImageTag,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListVulnerabilitySummariesRow{}
	for rows.Next() {
		var i ListVulnerabilitySummariesRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkloadName,
			&i.WorkloadType,
			&i.Namespace,
			&i.Cluster,
			&i.CurrentImageName,
			&i.CurrentImageTag,
			&i.ImageName,
			&i.ImageTag,
			&i.Critical,
			&i.High,
			&i.Medium,
			&i.Low,
			&i.Unassigned,
			&i.RiskScore,
			&i.WorkloadCreatedAt,
			&i.WorkloadUpdatedAt,
			&i.SummaryCreatedAt,
			&i.SummaryUpdatedAt,
			&i.HasSbom,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const refreshVulnerabilitySummaryDailyView = `-- name: RefreshVulnerabilitySummaryDailyView :exec
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_vuln_summary_daily_by_workload
`

func (q *Queries) RefreshVulnerabilitySummaryDailyView(ctx context.Context) error {
	_, err := q.db.Exec(ctx, refreshVulnerabilitySummaryDailyView)
	return err
}

const refreshVulnerabilitySummaryForDate = `-- name: RefreshVulnerabilitySummaryForDate :exec
WITH latest_summary_per_day AS (
    SELECT DISTINCT ON (w.id)
        $1::DATE AS snapshot_date,
        w.id AS workload_id,
        w.name AS workload_name,
        w.cluster,
        w.namespace,
        w.workload_type,
        COALESCE(vs.critical, 0) AS critical,
        COALESCE(vs.high, 0) AS high,
        COALESCE(vs.medium, 0) AS medium,
        COALESCE(vs.low, 0) AS low,
        COALESCE(vs.unassigned, 0) AS unassigned,
        COALESCE(vs.risk_score, 0) AS risk_score,
(vs.id IS NOT NULL) AS has_summary
    FROM
        workloads w
        LEFT JOIN vulnerability_summary vs ON w.image_name = vs.image_name
            AND w.image_tag = vs.image_tag
            AND vs.updated_at::DATE <= $1::DATE
        ORDER BY
            w.id,
            vs.updated_at DESC)
    INSERT INTO vuln_daily_by_workload(
        snapshot_date,
        workload_id,
        workload_name,
        cluster,
        namespace,
        workload_type,
        critical,
        high,
        medium,
        low,
        unassigned,
        total,
        risk_score,
        has_summary)
    SELECT
        snapshot_date,
        workload_id,
        workload_name,
        CLUSTER,
        namespace,
        workload_type,
        COALESCE(critical, 0)::INT4,
        COALESCE(high, 0)::INT4,
        COALESCE(medium, 0)::INT4,
        COALESCE(low, 0)::INT4,
        COALESCE(unassigned, 0)::INT4,
(COALESCE(critical, 0) + COALESCE(high, 0) + COALESCE(medium, 0) + COALESCE(low, 0) + COALESCE(unassigned, 0))::INT4,
        COALESCE(risk_score, 0)::INT4,
        has_summary
    FROM
        latest_summary_per_day
    ON CONFLICT (snapshot_date,
        workload_id)
        DO UPDATE SET
            critical = EXCLUDED.critical,
            high = EXCLUDED.high,
            medium = EXCLUDED.medium,
            low = EXCLUDED.low,
            unassigned = EXCLUDED.unassigned,
            total = EXCLUDED.total,
            risk_score = EXCLUDED.risk_score,
            has_summary = EXCLUDED.has_summary
`

func (q *Queries) RefreshVulnerabilitySummaryForDate(ctx context.Context, date pgtype.Date) error {
	_, err := q.db.Exec(ctx, refreshVulnerabilitySummaryForDate, date)
	return err
}
