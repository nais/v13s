// Code generated by sqlc. DO NOT EDIT.
// source: workloads.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addWorkloadEvent = `-- name: AddWorkloadEvent :exec
INSERT INTO workload_event_log (name,
                             workload_type,
                             namespace,
                             cluster,
                             event_type,
                             event_data,
                              subsystem)
VALUES ($1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7) ON
        CONFLICT DO NOTHING
`

type AddWorkloadEventParams struct {
	Name         string
	WorkloadType string
	Namespace    string
	Cluster      string
	EventType    string
	EventData    string
	Subsystem    string
}

func (q *Queries) AddWorkloadEvent(ctx context.Context, arg AddWorkloadEventParams) error {
	_, err := q.db.Exec(ctx, addWorkloadEvent,
		arg.Name,
		arg.WorkloadType,
		arg.Namespace,
		arg.Cluster,
		arg.EventType,
		arg.EventData,
		arg.Subsystem,
	)
	return err
}

const createWorkload = `-- name: CreateWorkload :one
INSERT INTO workloads (name, workload_type, namespace, cluster, image_name, image_tag)
VALUES ($1, $2, $3, $4, $5, $6) RETURNING
    id, name, workload_type, namespace, cluster, image_name, image_tag, created_at, updated_at, state
`

type CreateWorkloadParams struct {
	Name         string
	WorkloadType string
	Namespace    string
	Cluster      string
	ImageName    string
	ImageTag     string
}

func (q *Queries) CreateWorkload(ctx context.Context, arg CreateWorkloadParams) (*Workload, error) {
	row := q.db.QueryRow(ctx, createWorkload,
		arg.Name,
		arg.WorkloadType,
		arg.Namespace,
		arg.Cluster,
		arg.ImageName,
		arg.ImageTag,
	)
	var i Workload
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.WorkloadType,
		&i.Namespace,
		&i.Cluster,
		&i.ImageName,
		&i.ImageTag,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.State,
	)
	return &i, err
}

const deleteWorkload = `-- name: DeleteWorkload :one
DELETE
FROM workloads
WHERE name = $1
  AND workload_type = $2
  AND namespace = $3
  AND cluster = $4 RETURNING
    id
`

type DeleteWorkloadParams struct {
	Name         string
	WorkloadType string
	Namespace    string
	Cluster      string
}

func (q *Queries) DeleteWorkload(ctx context.Context, arg DeleteWorkloadParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, deleteWorkload,
		arg.Name,
		arg.WorkloadType,
		arg.Namespace,
		arg.Cluster,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const getWorkload = `-- name: GetWorkload :one
SELECT id, name, workload_type, namespace, cluster, image_name, image_tag, created_at, updated_at, state
FROM workloads
WHERE name = $1
  AND workload_type = $2
  AND namespace = $3
  AND cluster = $4
`

type GetWorkloadParams struct {
	Name         string
	WorkloadType string
	Namespace    string
	Cluster      string
}

func (q *Queries) GetWorkload(ctx context.Context, arg GetWorkloadParams) (*Workload, error) {
	row := q.db.QueryRow(ctx, getWorkload,
		arg.Name,
		arg.WorkloadType,
		arg.Namespace,
		arg.Cluster,
	)
	var i Workload
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.WorkloadType,
		&i.Namespace,
		&i.Cluster,
		&i.ImageName,
		&i.ImageTag,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.State,
	)
	return &i, err
}

const initializeWorkload = `-- name: InitializeWorkload :one
INSERT INTO workloads(name,
                      workload_type,
                      namespace,
                      cluster,
                      image_name,
                      image_tag,
                      state)
VALUES ($1,
        $2,
        $3,
        $4,
        $5,
        $6,
        'processing') ON CONFLICT
ON CONSTRAINT workload_id DO
UPDATE
    SET
        state = 'processing',
        updated_at = NOW(),
        image_name = $5,
        image_tag = $6
    WHERE workloads.state = 'failed' or
        workloads.state = 'resync' or
        (workloads.state != 'processing' and ( workloads.image_name != $5 or workloads.image_tag != $6 ))
    RETURNING
    id
`

type InitializeWorkloadParams struct {
	Name         string
	WorkloadType string
	Namespace    string
	Cluster      string
	ImageName    string
	ImageTag     string
}

func (q *Queries) InitializeWorkload(ctx context.Context, arg InitializeWorkloadParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, initializeWorkload,
		arg.Name,
		arg.WorkloadType,
		arg.Namespace,
		arg.Cluster,
		arg.ImageName,
		arg.ImageTag,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const listWorkloadsByCluster = `-- name: ListWorkloadsByCluster :many
SELECT id, name, workload_type, namespace, cluster, image_name, image_tag, created_at, updated_at, state
FROM workloads
WHERE cluster = $1
ORDER BY (name, namespace, cluster, updated_at) DESC
`

func (q *Queries) ListWorkloadsByCluster(ctx context.Context, cluster string) ([]*Workload, error) {
	rows, err := q.db.Query(ctx, listWorkloadsByCluster, cluster)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Workload{}
	for rows.Next() {
		var i Workload
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.WorkloadType,
			&i.Namespace,
			&i.Cluster,
			&i.ImageName,
			&i.ImageTag,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkloadsByImage = `-- name: ListWorkloadsByImage :many
SELECT id, name, workload_type, namespace, cluster, image_name, image_tag, created_at, updated_at, state
FROM workloads
WHERE image_name = $1
  AND image_tag = $2
ORDER BY (name, cluster, updated_at) DESC
`

type ListWorkloadsByImageParams struct {
	ImageName string
	ImageTag  string
}

func (q *Queries) ListWorkloadsByImage(ctx context.Context, arg ListWorkloadsByImageParams) ([]*Workload, error) {
	rows, err := q.db.Query(ctx, listWorkloadsByImage, arg.ImageName, arg.ImageTag)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Workload{}
	for rows.Next() {
		var i Workload
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.WorkloadType,
			&i.Namespace,
			&i.Cluster,
			&i.ImageName,
			&i.ImageTag,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setWorkloadState = `-- name: SetWorkloadState :many
WITH updated AS (
UPDATE workloads
SET state      = $1,
    updated_at = NOW()
WHERE ($2::TEXT IS NULL OR cluster = $2::TEXT)
  AND ($3::TEXT IS NULL OR namespace = $3::TEXT)
  AND ($4::TEXT IS NULL OR workload_type = $4::TEXT)
  AND ($5::TEXT IS NULL OR name = $5::TEXT)
  AND state = $6
    RETURNING id, name, workload_type, namespace, cluster, image_name, image_tag, created_at, updated_at, state
)
SELECT id, name, workload_type, namespace, cluster, image_name, image_tag, created_at, updated_at, state
FROM updated
ORDER BY cluster, namespace, name, updated_at DESC
`

type SetWorkloadStateParams struct {
	State        WorkloadState
	Cluster      *string
	Namespace    *string
	WorkloadType *string
	WorkloadName *string
	OldState     WorkloadState
}

type SetWorkloadStateRow struct {
	ID           pgtype.UUID
	Name         string
	WorkloadType string
	Namespace    string
	Cluster      string
	ImageName    string
	ImageTag     string
	CreatedAt    pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
	State        WorkloadState
}

func (q *Queries) SetWorkloadState(ctx context.Context, arg SetWorkloadStateParams) ([]*SetWorkloadStateRow, error) {
	rows, err := q.db.Query(ctx, setWorkloadState,
		arg.State,
		arg.Cluster,
		arg.Namespace,
		arg.WorkloadType,
		arg.WorkloadName,
		arg.OldState,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SetWorkloadStateRow{}
	for rows.Next() {
		var i SetWorkloadStateRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.WorkloadType,
			&i.Namespace,
			&i.Cluster,
			&i.ImageName,
			&i.ImageTag,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWorkloadState = `-- name: UpdateWorkloadState :exec
UPDATE workloads
SET state = $1
WHERE id = $2
`

type UpdateWorkloadStateParams struct {
	State WorkloadState
	ID    pgtype.UUID
}

func (q *Queries) UpdateWorkloadState(ctx context.Context, arg UpdateWorkloadStateParams) error {
	_, err := q.db.Exec(ctx, updateWorkloadState, arg.State, arg.ID)
	return err
}

const upsertWorkload = `-- name: UpsertWorkload :one
INSERT INTO workloads(name,
                      workload_type,
                      namespace,
                      cluster,
                      image_name,
                      image_tag,
                      state)
VALUES ($1,
        $2,
        $3,
        $4,
        $5,
        $6,
        'initialized') ON CONFLICT
ON CONSTRAINT workload_id DO
UPDATE
    SET
        image_name = $5,
    image_tag = $6,
    state = 'initialized',
    updated_at = NOW()
    RETURNING
    id
`

type UpsertWorkloadParams struct {
	Name         string
	WorkloadType string
	Namespace    string
	Cluster      string
	ImageName    string
	ImageTag     string
}

func (q *Queries) UpsertWorkload(ctx context.Context, arg UpsertWorkloadParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, upsertWorkload,
		arg.Name,
		arg.WorkloadType,
		arg.Namespace,
		arg.Cluster,
		arg.ImageName,
		arg.ImageTag,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}
