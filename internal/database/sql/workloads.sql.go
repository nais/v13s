// Code generated by sqlc. DO NOT EDIT.
// source: workloads.sql

package sql

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createWorkload = `-- name: CreateWorkload :one
INSERT INTO workloads (name, workload_type, namespace, cluster, image_name, image_tag)
VALUES ($1, $2, $3, $4, $5, $6) RETURNING
    id, name, workload_type, namespace, cluster, image_name, image_tag, created_at, updated_at, state
`

type CreateWorkloadParams struct {
	Name         string
	WorkloadType string
	Namespace    string
	Cluster      string
	ImageName    string
	ImageTag     string
}

func (q *Queries) CreateWorkload(ctx context.Context, arg CreateWorkloadParams) (*Workload, error) {
	row := q.db.QueryRow(ctx, createWorkload,
		arg.Name,
		arg.WorkloadType,
		arg.Namespace,
		arg.Cluster,
		arg.ImageName,
		arg.ImageTag,
	)
	var i Workload
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.WorkloadType,
		&i.Namespace,
		&i.Cluster,
		&i.ImageName,
		&i.ImageTag,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.State,
	)
	return &i, err
}

const deleteWorkload = `-- name: DeleteWorkload :one
DELETE
FROM workloads
WHERE name = $1
  AND workload_type = $2
  AND namespace = $3
  AND cluster = $4 RETURNING
    id
`

type DeleteWorkloadParams struct {
	Name         string
	WorkloadType string
	Namespace    string
	Cluster      string
}

func (q *Queries) DeleteWorkload(ctx context.Context, arg DeleteWorkloadParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, deleteWorkload,
		arg.Name,
		arg.WorkloadType,
		arg.Namespace,
		arg.Cluster,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const getWorkload = `-- name: GetWorkload :one
SELECT id, name, workload_type, namespace, cluster, image_name, image_tag, created_at, updated_at, state
FROM workloads
WHERE name = $1
  AND workload_type = $2
  AND namespace = $3
  AND cluster = $4
`

type GetWorkloadParams struct {
	Name         string
	WorkloadType string
	Namespace    string
	Cluster      string
}

func (q *Queries) GetWorkload(ctx context.Context, arg GetWorkloadParams) (*Workload, error) {
	row := q.db.QueryRow(ctx, getWorkload,
		arg.Name,
		arg.WorkloadType,
		arg.Namespace,
		arg.Cluster,
	)
	var i Workload
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.WorkloadType,
		&i.Namespace,
		&i.Cluster,
		&i.ImageName,
		&i.ImageTag,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.State,
	)
	return &i, err
}

const initializeWorkload = `-- name: InitializeWorkload :one
INSERT INTO workloads(name,
                      workload_type,
                      namespace,
                      cluster,
                      image_name,
                      image_tag,
                      state)
VALUES ($1,
        $2,
        $3,
        $4,
        $5,
        $6,
        'initialized') ON CONFLICT
ON CONSTRAINT workload_id DO
UPDATE
    SET
        state = 'initialized',
        updated_at = NOW(),
        image_name = $5,
        image_tag = $6
    WHERE workloads.state != 'initialized' and ( workloads.image_name != $5 or workloads.image_tag != $6 )
    RETURNING
    id, name, workload_type, namespace, cluster, image_name, image_tag, created_at, updated_at, state
`

type InitializeWorkloadParams struct {
	Name         string
	WorkloadType string
	Namespace    string
	Cluster      string
	ImageName    string
	ImageTag     string
}

func (q *Queries) InitializeWorkload(ctx context.Context, arg InitializeWorkloadParams) (*Workload, error) {
	row := q.db.QueryRow(ctx, initializeWorkload,
		arg.Name,
		arg.WorkloadType,
		arg.Namespace,
		arg.Cluster,
		arg.ImageName,
		arg.ImageTag,
	)
	var i Workload
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.WorkloadType,
		&i.Namespace,
		&i.Cluster,
		&i.ImageName,
		&i.ImageTag,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.State,
	)
	return &i, err
}

const listWorkloadsByCluster = `-- name: ListWorkloadsByCluster :many
SELECT id, name, workload_type, namespace, cluster, image_name, image_tag, created_at, updated_at, state
FROM workloads
WHERE cluster = $1
ORDER BY (name, namespace, cluster, updated_at) DESC
`

func (q *Queries) ListWorkloadsByCluster(ctx context.Context, cluster string) ([]*Workload, error) {
	rows, err := q.db.Query(ctx, listWorkloadsByCluster, cluster)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Workload{}
	for rows.Next() {
		var i Workload
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.WorkloadType,
			&i.Namespace,
			&i.Cluster,
			&i.ImageName,
			&i.ImageTag,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkloadsByImage = `-- name: ListWorkloadsByImage :many
SELECT id, name, workload_type, namespace, cluster, image_name, image_tag, created_at, updated_at, state
FROM workloads
WHERE image_name = $1
  AND image_tag = $2
ORDER BY (name, cluster, updated_at) DESC
`

type ListWorkloadsByImageParams struct {
	ImageName string
	ImageTag  string
}

func (q *Queries) ListWorkloadsByImage(ctx context.Context, arg ListWorkloadsByImageParams) ([]*Workload, error) {
	rows, err := q.db.Query(ctx, listWorkloadsByImage, arg.ImageName, arg.ImageTag)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Workload{}
	for rows.Next() {
		var i Workload
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.WorkloadType,
			&i.Namespace,
			&i.Cluster,
			&i.ImageName,
			&i.ImageTag,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWorkloadState = `-- name: UpdateWorkloadState :exec
UPDATE workloads
SET state = $1
WHERE id = $2
`

type UpdateWorkloadStateParams struct {
	State WorkloadState
	ID    pgtype.UUID
}

func (q *Queries) UpdateWorkloadState(ctx context.Context, arg UpdateWorkloadStateParams) error {
	_, err := q.db.Exec(ctx, updateWorkloadState, arg.State, arg.ID)
	return err
}

const upsertWorkload = `-- name: UpsertWorkload :one
INSERT INTO workloads(name,
                      workload_type,
                      namespace,
                      cluster,
                      image_name,
                      image_tag,
                      state)
VALUES ($1,
        $2,
        $3,
        $4,
        $5,
        $6,
        'initialized') ON CONFLICT
ON CONSTRAINT workload_id DO
UPDATE
    SET
        image_name = $5,
    image_tag = $6,
    state = 'initialized',
    updated_at = NOW()
    RETURNING
    id
`

type UpsertWorkloadParams struct {
	Name         string
	WorkloadType string
	Namespace    string
	Cluster      string
	ImageName    string
	ImageTag     string
}

func (q *Queries) UpsertWorkload(ctx context.Context, arg UpsertWorkloadParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, upsertWorkload,
		arg.Name,
		arg.WorkloadType,
		arg.Namespace,
		arg.Cluster,
		arg.ImageName,
		arg.ImageTag,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}
