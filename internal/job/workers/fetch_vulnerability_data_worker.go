package workers

import (
	"context"
	"errors"
	"fmt"

	"github.com/nais/v13s/internal/database/sql"
	"github.com/nais/v13s/internal/job"
	"github.com/nais/v13s/internal/job/jobs"
	"github.com/nais/v13s/internal/sources"
	"github.com/riverqueue/river"
	"github.com/sirupsen/logrus"
)

type FetchVulnerabilityDataForImagesWorker struct {
	Querier   sql.Querier
	Source    sources.Source
	JobClient job.Client
	Log       logrus.FieldLogger
	river.WorkerDefaults[jobs.FetchVulnerabilityDataForImagesJob]
}

func (f *FetchVulnerabilityDataForImagesWorker) Work(ctx context.Context, job *river.Job[jobs.FetchVulnerabilityDataForImagesJob]) error {
	if len(job.Args.Images) == 0 {
		f.Log.Info("no images provided for fetch job")
		return nil
	}

	var errs []error

	for _, img := range job.Args.Images {
		f.Log.Infof("fetching vulnerabilities for %s:%s", img.Name, img.Tag)

		vulnerabilities, err := f.Source.GetVulnerabilities(ctx, img.Name, img.Tag, true)
		if err != nil {
			errs = append(errs, fmt.Errorf("get vulnerabilities for %s:%s: %w", img.Name, img.Tag, err))
			continue
		}

		suppressedVulns, err := f.Querier.ListSuppressedVulnerabilitiesForImage(ctx, img.Name)
		if err != nil {
			errs = append(errs, fmt.Errorf("list suppressed vulnerabilities for %s:%s: %w", img.Name, img.Tag, err))
			continue
		}

		filtered := filterChangedSuppressed(vulnerabilities, suppressedVulns, img)

		eventTokens, err := f.Source.UpdateSuppressedVulnerabilities(ctx, filtered)
		if err != nil {
			errs = append(errs, fmt.Errorf("update suppressed vulnerabilities for %s:%s: %w", img.Name, img.Tag, err))
			continue
		}

		if len(eventTokens) > 0 {
			for _, e := range eventTokens {
				if err = f.JobClient.AddJob(ctx, &jobs.FinalizeAnalysisJob{
					ProjectID:    e.ProjectId,
					ImageName:    e.ImageName,
					ImageTag:     e.ImageTag,
					ProcessToken: e.Token,
				}); err != nil {
					errs = append(errs, fmt.Errorf("enqueue FinalizeAnalysisJob for project %s: %w", e.ProjectId, err))
				}
			}
			f.Log.WithField("count", len(eventTokens)).Info("queued analysis finalization jobs")
		} else {
			if err = f.JobClient.AddJob(ctx, &jobs.ProcessVulnerabilityDataJob{
				Batch: &sources.ImageVulnerabilityData{
					ImageName:       img.Name,
					ImageTag:        img.Tag,
					Source:          f.Source.Name(),
					Vulnerabilities: vulnerabilities,
				},
			}); err != nil {
				errs = append(errs, fmt.Errorf("enqueue ProcessVulnerabilityDataJob for %s:%s: %w", img.Name, img.Tag, err))
			}
		}
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}

	return nil
}

func filterChangedSuppressed(
	vulnerabilities []*sources.Vulnerability,
	suppressed []*sql.SuppressedVulnerability, // or whatever your querier returns
	img *sql.Image,
) []*sources.SuppressedVulnerability {
	filtered := make([]*sources.SuppressedVulnerability, 0, len(vulnerabilities))

	vulnMap := make(map[string]*sources.Vulnerability, len(vulnerabilities))
	for _, v := range vulnerabilities {
		key := v.Cve.Id + "|" + v.Package
		vulnMap[key] = v
	}

	for _, s := range suppressed {
		key := s.CveID + "|" + s.Package
		v, ok := vulnMap[key]
		if !ok {
			continue
		}

		if s.Suppressed != v.Suppressed {
			filtered = append(filtered, &sources.SuppressedVulnerability{
				ImageName:    img.Name,
				ImageTag:     img.Tag,
				CveId:        v.Cve.Id,
				Package:      v.Package,
				Suppressed:   s.Suppressed,
				Reason:       s.ReasonText,
				SuppressedBy: s.SuppressedBy,
				State:        vulnerabilitySuppressReasonToState(s.Reason),
				Metadata:     v.Metadata,
			})
		}
	}

	return filtered
}

func vulnerabilitySuppressReasonToState(reason sql.VulnerabilitySuppressReason) string {
	switch reason {
	case sql.VulnerabilitySuppressReasonFalsePositive:
		return "FALSE_POSITIVE"
	case sql.VulnerabilitySuppressReasonInTriage:
		return "IN_TRIAGE"
	case sql.VulnerabilitySuppressReasonNotAffected:
		return "NOT_AFFECTED"
	case sql.VulnerabilitySuppressReasonResolved:
		return "RESOLVED"
	default:
		return "NOT_SET"
	}
}
