package workers

import (
	"context"
	"fmt"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/nais/v13s/internal/collections"
	"github.com/nais/v13s/internal/database/sql"
	"github.com/nais/v13s/internal/job"
	"github.com/nais/v13s/internal/job/jobs"
	"github.com/nais/v13s/internal/manager"
	"github.com/nais/v13s/internal/sources"
	"github.com/riverqueue/river"
	"github.com/sirupsen/logrus"
)

type ProcessVulnerabilityDataWorker struct {
	Querier   sql.Querier
	JobClient job.Client
	Log       logrus.FieldLogger
	river.WorkerDefaults[jobs.ProcessVulnerabilityDataJob]
}

func (p *ProcessVulnerabilityDataWorker) Work(ctx context.Context, job *river.Job[jobs.ProcessVulnerabilityDataJob]) error {
	batch := job.Args.Batch

	var errs []error
	var batchErr error

	imageStates := make([]sql.BatchUpdateImageStateParams, 0)
	cves := make([]sql.BatchUpsertCveParams, 0)
	vulns := make([]sql.BatchUpsertVulnerabilitiesParams, 0)

	cves = append(cves, toCveSqlParams(batch)...)
	vulns = append(vulns, toVulnerabilitySqlParams(ctx, p.Querier, batch)...)
	imageStates = append(imageStates, sql.BatchUpdateImageStateParams{
		State: sql.ImageStateUpdated,
		Name:  batch.ImageName,
		Tag:   batch.ImageTag,
	})

	start := time.Now()
	errors := 0
	collections.SortByFields(cves, func(x sql.BatchUpsertCveParams) string {
		return x.CveID
	})
	p.Querier.BatchUpsertCve(ctx, cves).Exec(func(i int, err error) {
		if err != nil {
			p.Log.WithError(err).Debug("failed to batch upsert cves")
			batchErr = err
			errors++
			errs = append(errs, err)
		}
	})
	p.Log.WithError(batchErr).WithFields(logrus.Fields{
		"duration":   fmt.Sprintf("%fs", time.Since(start).Seconds()),
		"num_rows":   len(cves) - errors,
		"num_errors": errors,
	}).Infof("upserted batch of CVEs")

	start = time.Now()
	errors = 0
	collections.SortByFields(vulns,
		func(x sql.BatchUpsertVulnerabilitiesParams) string {
			return x.ImageName
		},
		func(x sql.BatchUpsertVulnerabilitiesParams) string {
			return x.ImageTag
		},
	)
	p.Querier.BatchUpsertVulnerabilities(ctx, vulns).Exec(func(i int, err error) {
		if err != nil {
			p.Log.WithError(err).Debug("failed to batch upsert vulnerabilities")
			batchErr = err
			errors++
			errs = append(errs, err)
		}
	})
	p.Log.WithError(batchErr).WithFields(logrus.Fields{
		"duration":   fmt.Sprintf("%fs", time.Since(start).Seconds()),
		"num_rows":   len(vulns) - errors,
		"num_errors": errors,
	}).Infof("upserted batch of vulnerabilities")

	if err := p.JobClient.AddJob(ctx, &manager.UpsertVulnerabilitySummariesJob{
		Images: []manager.Image{
			{
				Name: batch.ImageName,
				Tag:  batch.ImageTag,
			},
		},
	}); err != nil {
		p.Log.WithError(err).Error("failed to enqueue vulnerability summaries job")
		errs = append(errs, err)
	}

	if len(errs) == 0 {
		start = time.Now()
		errors = 0
		collections.SortByFields(imageStates,
			func(x sql.BatchUpdateImageStateParams) string { return x.Name },
			func(x sql.BatchUpdateImageStateParams) string { return x.Tag },
		)
		p.Querier.BatchUpdateImageState(ctx, imageStates).Exec(func(i int, err error) {
			if err != nil {
				p.Log.WithError(err).Debug("failed to batch update image state")
				batchErr = err
				errors++
				errs = append(errs, err)
			}
		})
		p.Log.WithError(batchErr).WithFields(logrus.Fields{
			"duration":   fmt.Sprintf("%fs", time.Since(start).Seconds()),
			"num_rows":   len(imageStates),
			"num_errors": errors,
		}).Infof("updated image states to 'updated'")
	}

	return nil
}

func toVulnerabilitySqlParams(ctx context.Context, querier sql.Querier, i *sources.ImageVulnerabilityData) []sql.BatchUpsertVulnerabilitiesParams {
	params := make([]sql.BatchUpsertVulnerabilitiesParams, 0)
	for _, v := range i.Vulnerabilities {
		severity := v.Cve.Severity.ToInt32()
		severitySince, err := DetermineSeveritySince(ctx, querier, i.ImageName, v.Package, v.Cve.Id, severity)
		if err != nil {
			logrus.Errorf("determine severitySince: %v", err)
		}
		batch := sql.BatchUpsertVulnerabilitiesParams{
			ImageName:     i.ImageName,
			ImageTag:      i.ImageTag,
			Package:       v.Package,
			CveID:         v.Cve.Id,
			Source:        i.Source,
			LatestVersion: v.LatestVersion,
			LastSeverity:  severity,
		}

		if severitySince != nil {
			batch.SeveritySince = pgtype.Timestamptz{
				Time:  *severitySince,
				Valid: true,
			}
		}
		params = append(params, batch)
	}
	return params
}

func DetermineSeveritySince(
	ctx context.Context,
	querier sql.Querier,
	imageName, pkg, cveID string,
	lastSeverity int32,
) (*time.Time, error) {

	earliest, err := querier.GetEarliestSeveritySinceForVulnerability(ctx, sql.GetEarliestSeveritySinceForVulnerabilityParams{
		ImageName:    imageName,
		Package:      pkg,
		CveID:        cveID,
		LastSeverity: lastSeverity,
	})
	if err != nil {
		return nil, err
	}

	if earliest.Valid {
		t := earliest.Time.UTC()
		return &t, nil
	}

	now := time.Now().UTC()
	return &now, nil
}

func toCveSqlParams(batch *sources.ImageVulnerabilityData) []sql.BatchUpsertCveParams {
	params := make([]sql.BatchUpsertCveParams, 0)
	for _, v := range batch.Vulnerabilities {
		params = append(params, sql.BatchUpsertCveParams{
			CveID:    v.Cve.Id,
			CveTitle: v.Cve.Title,
			CveDesc:  v.Cve.Description,
			CveLink:  v.Cve.Link,
			Severity: v.Cve.Severity.ToInt32(),
			Refs:     v.Cve.References,
		})
	}
	return params
}
