package worker

import (
	"context"
	"errors"
	"fmt"

	"github.com/nais/v13s/internal/collections"
	"github.com/nais/v13s/internal/database/sql"
	"github.com/nais/v13s/internal/postgresriver/riverjob"
	"github.com/nais/v13s/internal/postgresriver/riverjob/job"
	"github.com/riverqueue/river"
	"github.com/sirupsen/logrus"
)

type ProcessVulnerabilityDataBatchWorker struct {
	Querier   sql.Querier
	JobClient riverjob.Client
	Log       logrus.FieldLogger
	river.WorkerDefaults[job.ProcessVulnerabilityDataBatchJob]
}

func (p *ProcessVulnerabilityDataBatchWorker) Work(ctx context.Context, j *river.Job[job.ProcessVulnerabilityDataBatchJob]) error {
	ctx = riverjob.NewRecorder(ctx)
	rec := riverjob.FromContext(ctx)
	defer rec.Flush(ctx)

	rec.Add("start", "ok", fmt.Sprintf("batch_count=%d", len(j.Args.Batches)))

	var errs []error

	var cveRows []sql.BatchUpsertCveParams
	var vulnRows []sql.BatchUpsertVulnerabilitiesParams
	var imgStateRows []sql.BatchUpdateImageStateParams
	var summaryImages []job.Image

	rec.Add("collect_rows", "start", "")

	for _, b := range j.Args.Batches {
		cveRows = append(cveRows, toCveSqlParams(b)...)
		vulnRows = append(vulnRows, toVulnerabilitySqlParams(ctx, p.Querier, b)...)
		imgStateRows = append(imgStateRows, sql.BatchUpdateImageStateParams{
			State: sql.ImageStateUpdated,
			Name:  b.ImageName,
			Tag:   b.ImageTag,
		})
		summaryImages = append(summaryImages, job.Image{
			Name: b.ImageName,
			Tag:  b.ImageTag,
		})
	}

	rec.Add("collect_rows", "ok",
		fmt.Sprintf("cves=%d vulns=%d imgs=%d", len(cveRows), len(vulnRows), len(imgStateRows)),
	)

	// Batch CVE upsert
	rec.Add("upsert_cves", "start", fmt.Sprintf("count=%d", len(cveRows)))
	collections.SortByFields(cveRows, func(x sql.BatchUpsertCveParams) string { return x.CveID })
	cveErrCount := 0
	p.Querier.BatchUpsertCve(ctx, cveRows).Exec(func(_ int, err error) {
		if err != nil {
			cveErrCount++
			errs = append(errs, err)
		}
	})
	if cveErrCount > 0 {
		rec.Add("upsert_cves", "error", fmt.Sprintf("errors=%d", cveErrCount))
	} else {
		rec.Add("upsert_cves", "ok", "")
	}

	// Batch vuln upsert
	rec.Add("upsert_vulns", "start", fmt.Sprintf("count=%d", len(vulnRows)))
	collections.SortByFields(vulnRows,
		func(x sql.BatchUpsertVulnerabilitiesParams) string { return x.ImageName },
		func(x sql.BatchUpsertVulnerabilitiesParams) string { return x.ImageTag },
	)
	vulnErrCount := 0
	p.Querier.BatchUpsertVulnerabilities(ctx, vulnRows).Exec(func(_ int, err error) {
		if err != nil {
			vulnErrCount++
			errs = append(errs, err)
		}
	})
	if vulnErrCount > 0 {
		rec.Add("upsert_vulns", "error", fmt.Sprintf("errors=%d", vulnErrCount))
	} else {
		rec.Add("upsert_vulns", "ok", "")
	}

	// Update image states
	rec.Add("update_image_states", "start", fmt.Sprintf("count=%d", len(imgStateRows)))
	collections.SortByFields(imgStateRows,
		func(x sql.BatchUpdateImageStateParams) string { return x.Name },
		func(x sql.BatchUpdateImageStateParams) string { return x.Tag },
	)
	stateErrCount := 0
	p.Querier.BatchUpdateImageState(ctx, imgStateRows).Exec(func(_ int, err error) {
		if err != nil {
			stateErrCount++
			errs = append(errs, err)
		}
	})
	if stateErrCount > 0 {
		rec.Add("update_image_states", "error", fmt.Sprintf("errors=%d", stateErrCount))
	} else {
		rec.Add("update_image_states", "ok", "")
	}

	// Enqueue vulnerability summary job
	rec.Add("enqueue_summaries", "start", fmt.Sprintf("images=%d", len(summaryImages)))
	if err := p.JobClient.AddJob(ctx, &job.UpsertVulnerabilitySummariesJob{
		Images: summaryImages,
	}); err != nil {
		rec.Add("enqueue_summaries", "error", err.Error())
		errs = append(errs, fmt.Errorf("enqueue summaries job: %w", err))
	} else {
		rec.Add("enqueue_summaries", "ok", "")
	}

	if len(errs) > 0 {
		rec.Add("finish", "error", fmt.Sprintf("errors=%d", len(errs)))
		return errors.Join(errs...)
	}

	rec.Add("finish", "success", "")
	return nil
}
