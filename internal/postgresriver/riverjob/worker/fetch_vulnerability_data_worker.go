package worker

import (
	"context"
	"errors"
	"fmt"

	"github.com/nais/v13s/internal/database/sql"
	"github.com/nais/v13s/internal/postgresriver/riverjob"
	"github.com/nais/v13s/internal/postgresriver/riverjob/job"
	"github.com/nais/v13s/internal/sources"
	"github.com/riverqueue/river"
	"github.com/sirupsen/logrus"
)

type FetchVulnerabilityDataForImagesWorker struct {
	Querier   sql.Querier
	Source    sources.Source
	JobClient riverjob.Client
	Log       logrus.FieldLogger
	river.WorkerDefaults[job.FetchVulnerabilityDataForImagesJob]
}

func (f *FetchVulnerabilityDataForImagesWorker) Work(ctx context.Context, j *river.Job[job.FetchVulnerabilityDataForImagesJob]) error {
	ctx = riverjob.NewRecorder(ctx)
	rec := riverjob.FromContext(ctx)
	defer rec.Flush(ctx)

	imgCount := len(j.Args.Images)
	rec.Add("start", "ok", fmt.Sprintf("image_count=%d", imgCount))

	var errs []error
	var finalizeTokens []job.AnalysisTokenInfo
	var readyBatches []*sources.ImageVulnerabilityData

	fetchErrCount := 0
	suppressedErrCount := 0
	updateErrCount := 0
	changedSuppressedCount := 0

	for _, img := range j.Args.Images {
		vulnerabilities, err := f.Source.GetVulnerabilities(ctx, img.Name, img.Tag, true)
		if err != nil {
			if errors.Is(err, sources.ErrNoProject) || errors.Is(err, sources.ErrNoMetrics) {
				rec.Add("get_vulnerabilities", "skipped", fmt.Sprintf("no_project_or_metrics for %s:%s", img.Name, img.Tag))
				continue
			}
			fetchErrCount++
			errs = append(errs, fmt.Errorf("get vulnerabilities for %s:%s: %w", img.Name, img.Tag, err))
			continue
		}

		suppressedVulns, err := f.Querier.ListSuppressedVulnerabilitiesForImage(ctx, img.Name)
		if err != nil {
			suppressedErrCount++
			errs = append(errs, fmt.Errorf("list suppressed vulnerabilities for %s:%s: %w", img.Name, img.Tag, err))
			continue
		}

		filtered := filterChangedSuppressed(vulnerabilities, suppressedVulns, img)
		if len(filtered) > 0 {
			changedSuppressedCount += len(filtered)
		}

		eventTokens, err := f.Source.UpdateSuppressedVulnerabilities(ctx, filtered)
		if err != nil {
			updateErrCount++
			errs = append(errs, fmt.Errorf("update suppressed vulnerabilities for %s:%s: %w", img.Name, img.Tag, err))
			continue
		}

		if len(eventTokens) > 0 {
			for _, e := range eventTokens {
				finalizeTokens = append(finalizeTokens, job.AnalysisTokenInfo{
					ProjectID:    e.ProjectId,
					ImageName:    e.ImageName,
					ImageTag:     e.ImageTag,
					ProcessToken: e.Token,
				})
			}
		} else {
			readyBatches = append(readyBatches, &sources.ImageVulnerabilityData{
				ImageName:       img.Name,
				ImageTag:        img.Tag,
				Source:          f.Source.Name(),
				Vulnerabilities: vulnerabilities,
			})
		}
	}

	rec.Add("summary", "ok",
		fmt.Sprintf(
			"fetched_errors=%d suppressed_errors=%d update_errors=%d changed_suppressed=%d finalize_tokens=%d ready_batches=%d",
			fetchErrCount,
			suppressedErrCount,
			updateErrCount,
			changedSuppressedCount,
			len(finalizeTokens),
			len(readyBatches),
		),
	)

	// Enqueue finalize tokens if needed
	if len(finalizeTokens) > 0 {
		if err := f.JobClient.AddJob(ctx, &job.FinalizeAnalysisBatchJob{
			Tokens: finalizeTokens,
		}); err != nil {
			rec.Add("enqueue_finalize_batch", "error", err.Error())
			errs = append(errs, fmt.Errorf("enqueue finalize batch: %w", err))
		} else {
			rec.Add("enqueue_finalize_batch", "ok", fmt.Sprintf("tokens=%d", len(finalizeTokens)))
		}
	}

	// Enqueue ready batches
	if len(readyBatches) > 0 {
		if err := f.JobClient.AddJob(ctx, &job.ProcessVulnerabilityDataBatchJob{
			Batches: readyBatches,
		}); err != nil {
			rec.Add("enqueue_process_batch", "error", err.Error())
			errs = append(errs, fmt.Errorf("enqueue process batch: %w", err))
		} else {
			rec.Add("enqueue_process_batch", "ok", fmt.Sprintf("batches=%d", len(readyBatches)))
		}
	}

	if len(errs) > 0 {
		rec.Add("finish", "error", fmt.Sprintf("errors=%d", len(errs)))
		return errors.Join(errs...)
	}

	rec.Add("finish", "success", "")
	return nil
}

func filterChangedSuppressed(
	vulnerabilities []*sources.Vulnerability,
	suppressed []*sql.SuppressedVulnerability,
	img *sql.Image,
) []*sources.SuppressedVulnerability {
	filtered := make([]*sources.SuppressedVulnerability, 0, len(vulnerabilities))

	for _, s := range suppressed {
		for _, v := range vulnerabilities {
			if v.Cve.Id == s.CveID && v.Package == s.Package && s.Suppressed != v.Suppressed {
				filtered = append(filtered, &sources.SuppressedVulnerability{
					ImageName:    img.Name,
					ImageTag:     img.Tag,
					CveId:        v.Cve.Id,
					Package:      v.Package,
					Suppressed:   s.Suppressed,
					Reason:       s.ReasonText,
					SuppressedBy: s.SuppressedBy,
					State:        vulnerabilitySuppressReasonToState(s.Reason),
					Metadata:     v.Metadata,
				})
			}
		}
	}

	return filtered
}

func vulnerabilitySuppressReasonToState(reason sql.VulnerabilitySuppressReason) string {
	switch reason {
	case sql.VulnerabilitySuppressReasonFalsePositive:
		return "FALSE_POSITIVE"
	case sql.VulnerabilitySuppressReasonInTriage:
		return "IN_TRIAGE"
	case sql.VulnerabilitySuppressReasonNotAffected:
		return "NOT_AFFECTED"
	case sql.VulnerabilitySuppressReasonResolved:
		return "RESOLVED"
	default:
		return "NOT_SET"
	}
}
